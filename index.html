<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Code by Training 4Pilots clean -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <style>
        /* Quiz Container */
        #squarespace-quiz-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            left: 0;
            right: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Verbesserte horizontale Zentrierung */
            overflow: visible;
            /* Erlaubt sichtbare Elemente außerhalb des Containers */
            margin-bottom: 0 !important;
            /* Entfernt Abstand nach unten */
        }

        /* Mode Selection */
        #squarespace-quiz-container .mode-selection {
            text-align: center;
            padding: 0;
            /* Padding auf 0 reduziert */
            width: 100%;
            max-width: 760px;
            /* Anpassung an Breite des Quiz-Containers abzüglich Padding */
            margin: 0 auto 20px;
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: center;
            /* Hinzugefügt, um den Inhalt der Modusauswahl zu zentrieren */
        }

        #squarespace-quiz-container .mode-selection h2 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #fff;
            /* Weißer Text */
        }

        #squarespace-quiz-container .mode-selection p {
            font-size: 1rem;
            color: #fff;
            /* Weißer Text */
            margin-bottom: 30px;
        }

        /* Mode Options Container - Vereinfachtes Design für Squarespace */
        #squarespace-quiz-container .mode-options {
            display: flex;
            justify-content: center;
            align-items: stretch;
            /* Damit die Kacheln sich in der Höhe anpassen */
            gap: 20px;
            width: 100%;
            max-width: 760px;
            margin: 0 auto 2rem;
            flex-wrap: wrap;
            /* Wrap für mobile Ansicht */
        }

        /* Mode Option Card - Stark vereinfachte Version zur Vermeidung von Layout-Problemen */
        #squarespace-quiz-container .mode-option {
            flex: 1 1 320px;
            /* Flex-Grow aktiviert für gleiche Höhe */
            min-width: 280px;
            max-width: 320px;
            display: flex;
            flex-direction: column;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin: 0 0 10px 0;
            position: relative;
            overflow: visible;
            transition: box-shadow 0.3s ease;
        }

        #squarespace-quiz-container .mode-option:hover {
            /* Hover-Effekt vollständig entfernt, um Layout-Probleme zu vermeiden */
            transform: none !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #squarespace-quiz-container .mode-option.training-option {
            border-top: 4px solid #198754;
        }

        #squarespace-quiz-container .mode-option.exam-option {
            border-top: 4px solid #dc3545;
        }

        /* Mode Option Header - New */
        #squarespace-quiz-container .mode-option-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        #squarespace-quiz-container .mode-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            margin-right: 15px;
            color: white;
        }

        #squarespace-quiz-container .training-option .mode-icon {
            background-color: #198754;
        }

        #squarespace-quiz-container .exam-option .mode-icon {
            background-color: #dc3545;
        }

        #squarespace-quiz-container .mode-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1d232b;
        }

        /* Mode Description - New */
        #squarespace-quiz-container .mode-description {
            margin-bottom: 20px;
            color: #5c6670;
            line-height: 1.5;
            flex-grow: 1;
            /* Beschreibung kann wachsen */
        }

        #squarespace-quiz-container .mode-features {
            margin-bottom: 20px;
            flex-grow: 1;
            /* Wächst, um verfügbaren Platz zu füllen */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        #squarespace-quiz-container .feature-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 8px;
            justify-content: flex-start;
            /* Linksbündige Ausrichtung */
            width: 100%;
            /* Volle Breite nutzen */
            text-align: left;
            /* Text linksbündig ausrichten */
        }

        #squarespace-quiz-container .feature-icon {
            color: #198754;
            margin-right: 10px;
            flex-shrink: 0;
            margin-top: 3px;
            min-width: 14px;
            /* Fixe Breite für das Icon */
            text-align: center;
            /* Icon zentrieren */
        }

        #squarespace-quiz-container .feature-text {
            color: #1d232b;
            text-align: left;
            /* Text linksbündig */
            flex: 1;
            /* Text soll den verfügbaren Platz ausfüllen */
            word-break: break-word;
            /* Verhindert, dass lange Wörter abgeschnitten werden */
            hyphens: auto;
            /* Erlaubt Silbentrennung, wenn nötig */
        }

        #squarespace-quiz-container .exam-option .feature-icon {
            color: #dc3545;
        }

        /* Quiz Content */
        #squarespace-quiz-container .quiz-content {
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-top: 20px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Question text styles */
        #squarespace-quiz-container .question-text {
            font-size: 1.25rem;
            font-weight: 500;
            color: #1d232b;
            margin-bottom: 1.5rem;
            line-height: 1.4;
            display: block;
            padding: 0.5rem 0;
            text-align: center;
            width: 100%;
        }

        /* Question Container */
        #squarespace-quiz-container .question-container {
            padding: 20px 0;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Options Container */
        #squarespace-quiz-container .options-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            width: 100%;
            max-width: 600px;
        }

        /* Mode Selection Buttons */
        #squarespace-quiz-container .mode-button.training {
            background-color: #198754;
            color: white;
            padding: 12px 24px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            border-radius: 4px !important;
            font-size: 1rem;
            width: 100%;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-top: auto;
            /* Button am unteren Ende der Kachel */
        }

        #squarespace-quiz-container .mode-button.training:hover {
            background-color: #146c43;
            box-shadow: 0 4px 8px rgba(25, 135, 84, 0.2);
        }

        #squarespace-quiz-container .mode-button.exam {
            background-color: #dc3545;
            color: white;
            padding: 12px 24px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            border-radius: 4px !important;
            font-size: 1rem;
            width: 100%;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-top: auto;
            /* Button am unteren Ende der Kachel */
        }

        #squarespace-quiz-container .mode-button.exam:hover {
            background-color: #bb2d3b;
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.2);
        }

        /* Disabled button styles - Added for wrong questions button */
        #squarespace-quiz-container .mode-button.disabled,
        #squarespace-quiz-container .filter-button.disabled {
            background-color: #6c757d !important;
            color: #e6e6e6 !important;
            cursor: not-allowed !important;
            opacity: 0.65 !important;
            pointer-events: none !important;
        }

        /* Question Overview */
        #squarespace-quiz-container .question-overview {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto;
            padding: 8px 20px;
            /* Extra seitliches Padding für Desktop */
            overflow: visible;
            width: 100%;
            max-width: 650px;
            /* Erhöhte Breite für mehr Platz */
            box-sizing: border-box;
            /* Sicherstellen, dass Padding innerhalb der Breite bleibt */
        }

        /* Overview Container */
        #squarespace-quiz-container .overview-scroll-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            overflow-x: auto;
            padding: 0 10px;
            /* Hinzugefügtes Padding, um Platz für die äußeren Kästchen zu schaffen */
            width: calc(100% - 90px);
            /* Mehr Platz auf beiden Seiten reservieren */
            margin: 0 auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            white-space: nowrap;
            min-height: 40px;
        }

        /* Navigation Buttons - Mobile-First Styling (Default) */
        #squarespace-quiz-container .nav-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background-color: #1d232b;
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        #squarespace-quiz-container .nav-button:hover {
            background-color: #2a3441;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transform: translateY(-50%) scale(1.05);
        }

        /* Left navigation button */
        #squarespace-quiz-container .nav-button.prev {
            left: 0;
        }

        /* Right navigation button */
        #squarespace-quiz-container .nav-button.next {
            right: 0;
        }

        /* Desktop view - Navigation buttons positioned outward (but not too far) */
        @media (min-width: 768px) {

            /* Gleiche Höhe für die Moduskacheln im Desktop-Layout */
            #squarespace-quiz-container .mode-options {
                display: flex;
                align-items: stretch;
                gap: 20px;
            }

            #squarespace-quiz-container .mode-option {
                display: flex;
                flex-direction: column;
                flex: 1;
                height: auto;
                box-sizing: border-box;
                position: relative;
                padding-bottom: 70px;
                /* Platz für den Button */
            }

            #squarespace-quiz-container .mode-features {
                flex-grow: 1;
                margin-bottom: 20px;
            }

            #squarespace-quiz-container .mode-button.training,
            #squarespace-quiz-container .mode-button.exam {
                position: absolute;
                bottom: 20px;
                left: 15px;
                right: 15px;
                width: calc(100% - 30px);
            }

            #squarespace-quiz-container .question-overview {
                padding: 8px 30px;
                /* Größerer Container für Desktop */
                max-width: 700px;
                /* Erweiterte maximale Breite für Desktop */
                margin: 0 auto;
                position: relative;
                /* Stellt sicher, dass die Buttons korrekt positioniert werden */
            }

            #squarespace-quiz-container .overview-scroll-container {
                padding: 0 15px;
                /* Mehr Padding für die Übersichtsleiste */
                width: calc(100% - 100px);
                /* Mehr Platz auf beiden Seiten */
            }

            #squarespace-quiz-container .nav-button.prev {
                left: -5px !important;
                /* Minimale Verschiebung nach außen */
            }

            #squarespace-quiz-container .nav-button.next {
                right: -5px !important;
                /* Minimale Verschiebung nach außen */
            }
        }

        /* For larger screens - more padding for content area */
        @media (min-width: 992px) {
            #squarespace-quiz-container .question-overview {
                padding: 8px 35px;
                /* Noch mehr Platz für größere Bildschirme */
                max-width: 750px;
                /* Noch breiterer Container für größere Bildschirme */
            }

            #squarespace-quiz-container .overview-scroll-container {
                padding: 0 20px;
                /* Noch mehr Padding für große Bildschirme */
                width: calc(100% - 120px);
                /* Noch mehr Platz an den Seiten */
            }

            #squarespace-quiz-container .nav-button.prev {
                left: -8px !important;
                /* Reduzierte Verschiebung nach außen */
            }

            #squarespace-quiz-container .nav-button.next {
                right: -8px !important;
                /* Reduzierte Verschiebung nach außen */
            }
        }

        #squarespace-quiz-container #overview-container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 6px;
            margin: 0 auto;
        }

        /* Question Indicators - Updated to handle numbers up to 999 */
        #squarespace-quiz-container .question-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            /* Increased width to handle 3-digit numbers */
            width: auto;
            /* Changed to auto to allow growth based on content */
            height: 32px;
            /* Increased height slightly */
            padding: 0 4px;
            /* Added padding for better spacing */
            background-color: #1d232b;
            color: #f8f9fa;
            cursor: pointer;
            font-weight: 500;
            border: 2px solid transparent;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.8rem;
            /* Slightly smaller font size to fit numbers better */
        }

        #squarespace-quiz-container .question-indicator.current {
            border-color: #1d232b;
            background-color: white;
            color: #1d232b;
        }

        #squarespace-quiz-container .question-indicator.correct {
            background-color: #198754;
            border-color: transparent;
            color: #f8f9fa;
        }

        /* Aktuelle Frage, die korrekt beantwortet wurde */
        #squarespace-quiz-container .question-indicator.current.correct {
            background-color: #198754;
            border-color: #1d232b;
            color: #f8f9fa;
        }

        #squarespace-quiz-container .question-indicator.incorrect {
            background-color: #dc3545;
            border-color: transparent;
            color: #f8f9fa;
        }

        /* Beantwortete Frage im Prüfungsmodus - neutral grau */
        #squarespace-quiz-container .question-indicator.answered {
            background-color: #6c757d;
            /* Neutrales Grau */
            border-color: transparent;
            color: #f8f9fa;
        }

        /* Aktuelle beantwortete Frage im Prüfungsmodus */
        #squarespace-quiz-container .question-indicator.current.answered {
            background-color: #6c757d;
            /* Dunkler Grauton */
            border-color: #1d232b;
            color: #f8f9fa;
        }

        /* Aktuelle Frage, die falsch beantwortet wurde */
        #squarespace-quiz-container .question-indicator.current.incorrect {
            background-color: #dc3545;
            border-color: #1d232b;
            color: #f8f9fa;
        }

        #squarespace-quiz-container .question-indicator.marked {
            background-color: #ffc107;
            border-color: transparent;
            color: #5c6670;
        }

        /* Markierte Frage, die aktuell ausgewählt ist */
        #squarespace-quiz-container .question-indicator.marked.current {
            background-color: #ffc107;
            border-color: #1d232b;
            color: #5c6670;
        }

        /* Neue Klassen für markierte Fragen, die beantwortet wurden */
        #squarespace-quiz-container .question-indicator.marked-correct {
            /* Markierte Frage mit korrekter Antwort: Orange-Hintergrund mit grünem Rand */
            background-color: #ffc107;
            border: 2px solid #198754;
            color: #5c6670;
        }

        #squarespace-quiz-container .question-indicator.marked-incorrect {
            /* Markierte Frage mit falscher Antwort: Orange-Hintergrund mit rotem Rand */
            background-color: #ffc107;
            border: 2px solid #dc3545;
            color: #5c6670;
        }


        /* Navigation Buttons - Basis Styling für alle Bildschirmgrößen */
        #squarespace-quiz-container .nav-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: #1d232b;
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
            border-radius: 4px;
            font-size: 0.875rem;
        }

        #squarespace-quiz-container .nav-button i {
            font-size: 0.875rem;
        }

        /* Diese Styles werden durch die Media Queries oben überschrieben */
        #squarespace-quiz-container .nav-button.prev {
            left: 0;
            /* Für mobile Ansicht */
        }

        #squarespace-quiz-container .nav-button.next {
            right: 0;
            /* Für mobile Ansicht */
        }

        /* Action Buttons - Updated for better navigation experience */
        #squarespace-quiz-container .action-buttons {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            gap: 12px;
            padding: 0 10px;
        }

        #squarespace-quiz-container .back-button,
        #squarespace-quiz-container .next-button {
            min-width: 32px;
            width: 32px;
            height: 32px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #1d232b;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px !important;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        #squarespace-quiz-container .back-button:hover,
        #squarespace-quiz-container .next-button:hover {
            background-color: #2a3441;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }

        #squarespace-quiz-container .back-button i,
        #squarespace-quiz-container .next-button i {
            font-size: 0.95rem;
        }

        /* Mobile Optimizations - Updated for better centering */
        @media (max-width: 768px) {
            #squarespace-quiz-container {
                margin: 10px auto;
                padding: 15px;
            }

            #squarespace-quiz-container .quiz-content {
                padding: 15px;
            }

            #squarespace-quiz-container .question-overview {
                margin: 0 auto;
                width: 100%;
                /* Volle Breite nehmen */
            }

            #squarespace-quiz-container .overview-container-with-buttons {
                width: 100%;
            }

            #squarespace-quiz-container .overview-scroll-container {
                padding: 0 5px;
                /* Ein bisschen Padding auch auf Mobilgeräten */
                margin: 0 30px;
                /* Platz für die Buttons */
                width: calc(100% - 60px);
                /* Angepasste Breite für Mobilgeräte */
            }

            #squarespace-quiz-container .nav-button,
            #squarespace-quiz-container .back-button,
            #squarespace-quiz-container .next-button {
                min-width: 26px;
                width: 26px;
                height: 26px;
                font-size: 0.85rem;
            }

            #squarespace-quiz-container .question-indicator {
                min-width: 32px;
                /* Wider for three-digit numbers */
                width: auto;
                /* Allow width to adjust to content */
                height: 28px;
                padding: 0 3px;
                /* Add padding for better spacing */
                font-size: 0.75rem;
                /* Slightly smaller font */
            }

            #squarespace-quiz-container .nav-button i,
            #squarespace-quiz-container .back-button i,
            #squarespace-quiz-container .next-button i {
                font-size: 0.85rem;
            }

            /* Verbesserte Styles für die Mode-Options im Mobile Layout */
            #squarespace-quiz-container .mode-options {
                flex-direction: column;
                /* Ändere zu column für vertikale Stapelung */
                align-items: center;
                /* Zentriere die Kacheln horizontal */
                justify-content: center;
                width: 100%;
                /* Stellt sicher, dass die Container volle Breite hat */
                margin: 0 auto;
                gap: 20px;
                /* Reduzierter Abstand zwischen Kacheln */
            }

            #squarespace-quiz-container .mode-option {
                width: 100%;
                /* Volle verfügbare Breite nutzen */
                max-width: 320px;
                /* Maximale Breite für besseres Layout */
                min-width: auto;
                /* Entfernt die Mindestbreite-Beschränkung im mobilen Layout */
                margin: 0 auto;
                /* Auto-Margins für horizontale Zentrierung */
                box-sizing: border-box;
                /* Box-Sizing sicherstellen */
                position: relative;
                padding-bottom: 70px;
                /* Platz für den Button */
                min-height: 380px;
                /* Mindesthöhe, um alle Feature-Punkte anzuzeigen */
                display: flex;
                flex-direction: column;
            }

            #squarespace-quiz-container .mode-button.training,
            #squarespace-quiz-container .mode-button.exam {
                position: absolute;
                bottom: 20px;
                left: 15px;
                right: 15px;
                width: calc(100% - 30px);
            }
        }

        @media (max-width: 576px) {
            #squarespace-quiz-container {
                margin: 5px auto;
                padding: 10px;
            }

            #squarespace-quiz-container .quiz-content {
                padding: 10px;
            }

            #squarespace-quiz-container .question-overview {
                margin: 0 auto;
                width: 100%;
                /* Volle Breite nehmen */
            }

            #squarespace-quiz-container .overview-container-with-buttons {
                width: 100%;
            }

            #squarespace-quiz-container .overview-scroll-container {
                padding: 0 5px;
                /* Ein bisschen Padding auch auf kleinen Mobilgeräten */
                margin: 0 28px;
                /* Platz für die Buttons */
                width: calc(100% - 56px);
                /* Angepasste Breite für kleine Mobilgeräte */
            }

            #squarespace-quiz-container .nav-button,
            #squarespace-quiz-container .back-button,
            #squarespace-quiz-container .next-button {
                min-width: 24px;
                width: 24px;
                height: 24px;
                font-size: 0.8rem;
            }

            #squarespace-quiz-container .question-indicator {
                min-width: 30px;
                /* Width for three-digit numbers */
                width: auto;
                /* Allow growth */
                height: 26px;
                padding: 0 2px;
                /* Smaller padding */
                font-size: 0.7rem;
                /* Smaller font for small screens */
            }

            #squarespace-quiz-container .nav-button i,
            #squarespace-quiz-container .back-button i,
            #squarespace-quiz-container .next-button i {
                font-size: 0.8rem;
            }

            #squarespace-quiz-container .mode-option {
                padding: 15px;
                min-height: 430px;
                /* Weiter erhöhte Mindesthöhe für kleinere Bildschirme */
            }

            #squarespace-quiz-container .mode-option.exam-option {
                min-height: 440px;
                /* Extra Höhe für den Prüfungsmodus, der längere Texte hat */
            }

            /* Kleinere Modals für mobile Ansicht */
            .modal-content {
                max-width: 280px;
                width: 80%;
                padding: 20px 15px;
            }

            .modal-button {
                min-width: 70px;
                height: 36px;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 380px) {
            #squarespace-quiz-container .mode-option {
                min-height: 440px;
                /* Nochmals erhöhte Mindesthöhe für sehr kleine Bildschirme */
            }

            #squarespace-quiz-container .mode-option.exam-option {
                min-height: 460px;
                /* Extra Höhe für den Prüfungsmodus auf sehr kleinen Bildschirmen */
            }

            #squarespace-quiz-container .question-overview {
                margin: 0 auto;
                width: 100%;
                /* Volle Breite nehmen */
            }

            #squarespace-quiz-container .overview-container-with-buttons {
                width: 100%;
            }

            #squarespace-quiz-container .overview-scroll-container {
                padding: 0;
                margin: 0 24px;
                /* Platz für die Buttons */
            }

            #squarespace-quiz-container .nav-button,
            #squarespace-quiz-container .back-button,
            #squarespace-quiz-container .next-button {
                min-width: 22px;
                width: 22px;
                height: 22px;
                font-size: 0.75rem;
            }

            #squarespace-quiz-container .question-indicator {
                min-width: 28px;
                /* Width for three-digit numbers */
                width: auto;
                /* Allow growth */
                height: 24px;
                padding: 0 1px;
                /* Minimal padding */
                font-size: 0.65rem;
                /* Smaller font for small screens */
            }

            #squarespace-quiz-container .nav-button i,
            #squarespace-quiz-container .back-button i,
            #squarespace-quiz-container .next-button i {
                font-size: 0.75rem;
            }

            /* Noch kleinere Modals für sehr kleine Bildschirme */
            .modal-content {
                max-width: 250px;
                width: 75%;
                padding: 15px 12px;
            }

            .modal-button {
                min-width: 60px;
                height: 32px;
                font-size: 0.85rem;
            }

            .modal-footer {
                gap: 10px;
            }

            #modal-body {
                font-size: 14px;
            }

            .modal-container h2 {
                font-size: 1.25rem;
            }
        }

        /* Progress Bar */
        #squarespace-quiz-container .progress-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 30px auto;
            padding: 0;
            width: 100%;
            /* Nimmt die volle Breite des Elternelements */
            max-width: 600px;
            /* Exakt dieselbe Breite wie die Antwortboxen */
            position: relative;
            box-sizing: border-box;
            /* Wichtig für konsistente Breitenberechnung */
        }

        #squarespace-quiz-container .progress-container {
            width: 100%;
            /* Take full width of parent */
            height: 8px;
            background-color: #1d232b;
            margin: 0 auto;
            overflow: hidden;
            border-radius: 4px;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        #squarespace-quiz-container .progress-bar {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            width: 100%;
        }

        /* Fortschrittsanzeige im Trainingsmodus (rot/grün) */
        #squarespace-quiz-container .progress-bar.training-mode {
            background: linear-gradient(to right,
                    #198754 var(--correct-percentage),
                    #dc3545 var(--correct-percentage) var(--answered-percentage),
                    #1d232b var(--answered-percentage));
        }

        /* Fortschrittsanzeige im Prüfungsmodus (nur grau) */
        #squarespace-quiz-container .progress-bar.exam-mode {
            background: linear-gradient(to right,
                    #6c757d var(--answered-percentage),
                    #1d232b var(--answered-percentage));
        }

        #squarespace-quiz-container .progress-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            font-weight: 500;
            text-align: center;
            width: 100%;
        }



        /* Results Container Styling - Updated for better centering */
        #squarespace-quiz-container .results-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 600px;
            /* Match with question and options containers */
            margin: 0 auto;
            padding: 20px 0;
            position: relative;
            background: transparent;
        }

        #squarespace-quiz-container .chart-container {
            width: 300px;
            height: 300px;
            margin: -5px auto 0;
            /* Negative top margin to pull it up and remove gap */
            background: transparent;
            padding-top: 0;
            /* Ensure no padding at top */
        }

        #squarespace-quiz-container .results-text {
            text-align: center;
            font-size: 1.1rem;
            line-height: 1.6;
            margin: 1rem 0;
            color: #1d232b;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #squarespace-quiz-container .results-text span {
            display: block;
            width: 100%;
            max-width: 480px;
            /* Alle Boxen werden die gleiche Breite haben */
            padding: 0.5rem 1rem;
            margin: 0.25rem 0;
            text-align: left;
            border-radius: 4px;
        }

        #squarespace-quiz-container .text-unanswered {
            color: white;
            font-weight: 500;
            background-color: #1d232b;
            border-radius: 4px;
            margin: 0.5rem 0;
            width: 100%;
            box-sizing: border-box;
        }

        #squarespace-quiz-container .wrong-answers {
            width: 100%;
            max-width: 600px;
            margin: 1rem auto;
        }

        #squarespace-quiz-container .wrong-answers-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
        }

        #squarespace-quiz-container .wrong-answers-list h3 {
            text-align: center;
            margin-bottom: 1.5rem;
            font-size: 1.25rem;
            color: #1d232b;
            font-weight: 600;
        }

        #squarespace-quiz-container .wrong-answer-item {
            background: #fff;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
            border: 1px solid #dee2e6;
            transition: transform 0.2s ease;
        }

        #squarespace-quiz-container .wrong-answer-item:hover {
            transform: translateY(-2px);
        }

        #squarespace-quiz-container .wrong-answer-item p {
            margin: 0.75rem 0;
            color: #1d232b;
            font-size: 1rem;
            line-height: 1.5;
        }

        #squarespace-quiz-container .wrong-answer-item strong {
            color: #1d232b;
            font-weight: 600;
            display: block;
            margin-bottom: 0.5rem;
        }

        #squarespace-quiz-container .text-danger {
            color: #dc3545 !important;
            font-weight: 500;
            background: rgba(220, 53, 69, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            margin: 0.5rem 0;
            width: 100%;
            box-sizing: border-box;
        }

        #squarespace-quiz-container .text-success {
            color: #198754 !important;
            font-weight: 500;
            background: rgba(25, 135, 84, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            margin: 0.5rem 0;
            width: 100%;
            box-sizing: border-box;
        }

        /* Mode Switch - Reference for Centering */
        #squarespace-quiz-container .mode-switch {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 20px 0;
            margin-top: 20px;
        }

        /* Action Buttons */
        #squarespace-quiz-container .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            max-width: 300px;
            margin: 0 15px;
        }

        #squarespace-quiz-container .action-button {
            height: 40px;
            padding: 0 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #1d232b;
            color: white;
            transition: all 0.2s ease;
            min-width: 40px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        /* Submit Button */
        #squarespace-quiz-container .submit-button {
            background-color: #198754;
        }

        /* Mark Button */
        #squarespace-quiz-container .mark-button {
            background-color: #ffc107;
        }

        /* Reset Button */
        #squarespace-quiz-container .reset-button {
            background-color: #dc3545;
        }

        #squarespace-quiz-container .action-button:disabled {
            opacity: 0.65;
            cursor: not-allowed;
        }

        #squarespace-quiz-container .action-button:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Modal Styling */
        .modal-container {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
        }

        /* !important: Modifikator für alle Modal Container */
        .modal-container.show {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        .modal-content {
            position: relative;
            background-color: #1d232b;
            color: white;
            margin: auto;
            padding: 25px;
            border-radius: 5px;
            border: 1px solid #2c3642;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            max-width: 360px;
            width: 80%;
            /* Reduzierte Breite */
            text-align: center;
            animation: modalopen 0.3s;
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Mobile Stile für Modals direkt hier definieren, damit sie Priorität haben */
        @media screen and (max-width: 767px) {
            .modal-content {
                max-width: 350px !important;
                width: 75% !important;
                /* Entspricht den gewünschten 70-75% */
                padding: 20px 15px !important;
                display: flex !important;
                flex-direction: column !important;
                align-items: center !important;
            }

            .modal-container h2 {
                font-size: 1.25rem !important;
            }

            #modal-body {
                font-size: 14px !important;
                width: 100% !important;
            }

            .modal-button {
                min-width: 70px !important;
                height: 36px !important;
                font-size: 0.9rem !important;
            }
        }

        @media screen and (max-width: 480px) {
            .modal-content {
                max-width: 260px !important;
                width: 70% !important;
                padding: 15px 12px !important;
            }

            .modal-footer {
                flex-direction: column !important;
                gap: 10px !important;
            }

            .modal-button {
                width: 100% !important;
                min-width: 100px !important;
                height: 36px !important;
                font-size: 0.85rem !important;
            }
        }

        @keyframes modalopen {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-close {
            position: absolute;
            right: 15px;
            top: 10px;
            color: #aaa;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        .modal-close:hover {
            color: white;
        }

        .modal-container h2 {
            margin-top: 0;
            color: white;
            font-size: 1.5rem;
        }

        #modal-body {
            font-size: 16px;
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .modal-button {
            height: 40px;
            padding: 0 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            min-width: 80px;
            display: inline-flex;
            align-items: center;
            text-transform: lowercase !important;
            justify-content: center;
            gap: 8px;
        }

        .modal-button-primary {
            background-color: #198754;
            color: white;
        }

        .modal-button-primary:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .modal-button-secondary {
            background-color: #dc3545;
            color: white;
        }

        .modal-button-secondary:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* When modal is active, prevent scrolling on the background */
        body.modal-open {
            overflow: hidden;
        }

        /* Show modal when needed */
        .modal-container.show {
            display: flex;
        }


        #squarespace-quiz-container .option-button {
            width: 100%;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background-color: white;
            color: #212529;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #squarespace-quiz-container .option-button:hover {
            transform: translateY(-2px);
        }

        #squarespace-quiz-container .option-button.correct {
            background-color: #198754;
            color: white;
            border-color: #198754;
        }

        #squarespace-quiz-container .option-button.incorrect {
            background-color: #dc3545;
            color: white;
            border-color: #dc3545;
        }

        #squarespace-quiz-container .option-button.selected-exam {
            background-color: #e9ecef;
            border-color: #6c757d;
            color: #212529;
        }

        /* Filter Buttons Styling */
        #squarespace-quiz-container .filter-buttons {
            display: flex;
            gap: 1rem;
            margin: 1.5rem 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Verstecke Filter-Buttons im Prüfungsmodus - mit höchster Priorität */
        body.exam-mode #squarespace-quiz-container .filter-buttons {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
            position: absolute !important;
            left: -9999px !important;
            height: 0 !important;
            width: 0 !important;
            overflow: hidden !important;
        }

        /* Zusätzliche Maßnahme: Verstecke filter-button Elemente einzeln im Prüfungsmodus */
        body.exam-mode #squarespace-quiz-container .filter-button {
            display: none !important;
        }

        #squarespace-quiz-container .filter-button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        #squarespace-quiz-container .filter-button.marked-questions {
            background-color: #ffc107;
            color: #1d232b;
        }

        #squarespace-quiz-container .filter-button.wrong-questions {
            background-color: #dc3545;
            color: white;
        }

        #squarespace-quiz-container .filter-button:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Filter Button Updates */
        #squarespace-quiz-container .filter-button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none !important;
            background-color: rgba(108, 117, 125, 0.3) !important;
            /* Leichterer Grauton mit Transparenz */
            color: rgba(255, 255, 255, 0.8) !important;
        }

        #squarespace-quiz-container .filter-button.marked-questions:disabled {
            background-color: rgba(255, 193, 7, 0.7) !important;
            /* Abgeschwächtes Gelb */
            color: rgba(29, 35, 43, 0.8) !important;
        }

        #squarespace-quiz-container .filter-button.wrong-questions:disabled {
            background-color: rgba(220, 53, 69, 0.7) !important;
            /* Abgeschwächtes Rot */
            color: rgba(255, 255, 255, 0.8) !important;
        }

        /* Mobile Responsiveness for Progress Bar and Filter Buttons */
        @media (max-width: 768px) {
            #squarespace-quiz-container .filter-buttons {
                flex-direction: column;
                gap: 10px;
            }

            #squarespace-quiz-container .filter-button {
                width: 100%;
                justify-content: center;
            }

            /* Wichtig: Einheitliche Container-Breite für alle Elemente */
            #squarespace-quiz-container .question-container,
            #squarespace-quiz-container .options-container,
            #squarespace-quiz-container .progress-section,
            #squarespace-quiz-container .results-container {
                width: calc(100% - 30px);
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                box-sizing: border-box;
            }

            /* Die Progress Bar sollte keine inneren Abstände haben */
            #squarespace-quiz-container .progress-section {
                padding: 0;
            }

            /* Aber der progress-container sollte genau so breit sein wie die anderen Container */
            #squarespace-quiz-container .progress-container {
                width: 100%;
                margin: 0 auto;
            }
        }

        @media (max-width: 576px) {

            /* Kleinerer Randabstand für kleinere Bildschirme */
            #squarespace-quiz-container .question-container,
            #squarespace-quiz-container .options-container,
            #squarespace-quiz-container .progress-section,
            #squarespace-quiz-container .results-container {
                width: calc(100% - 20px);
            }
        }

        @media (max-width: 767.98px) { 
            #squarespace-quiz-container .mode-selection h2, #squarespace-quiz-container .mode-selection p{
                display: none;
            }
            .mode-option.training-option{
                display: block !important;
            }
            #squarespace-quiz-container .mode-option{
                min-height: fit-content !important;
            }
            .mode-button.exam {
                display: block !important;
                position: relative !important;
                width: 100% !important;
                left: inherit !important;
                right: inherit !important;
            }
            .quiz-content {
                height: 45rem;
            }
            #squarespace-quiz-container .action-buttons {
                position: absolute;
                bottom: 34px;
                left: 50%;
                transform: translateX(-50%);
                width: 100%;
            }
            .cactionbtn {
                position: relative !important;
                left: inherit !important;
                transform: inherit !important;
            }
         }
         @media (max-width: 420px) {

            #squarespace-quiz-container .mode-icon{
                width: 28px;
                height: 28px;
                font-size: 12px;
            }
            .quiz-content {
                height: 90vh;
            }
            #squarespace-quiz-container .mode-description{
                font-size: 12px;
                line-height: normal;
                margin-bottom: 10px;
            }
            .mode-button.training {
                position: relative !important;
                font-size: 12px !important;
            }
            #squarespace-quiz-container .mode-option {
                min-height: auto !important;
                height: auto !important;
                flex: auto;
            }
            .question-container {
                margin-top: 0 !important;
                padding-top: 0 !important;
            }
            .question-text {
                padding: 0 !important;
                margin: 0 !important;
            }
        }
    </style>
</head>

<body>


    <div id="squarespace-quiz-container">
        <div class="mode-selection">
            <h2>Wähle deinen Test-Modus</h2>
            <p>Wähle den passenden Modus für dein Lernziel. Im Trainingsmodus lernst du mit sofortigem Feedback, im
                Prüfungsmodus testest du dein Wissen unter realistischen Bedingungen.</p>

            <div class="mode-options">
                <!-- Trainingsmodus Karte -->
                <div class="mode-option training-option">
                    <div class="mode-option-header">
                        <div class="mode-icon">
                            <i class="fas fa-graduation-cap"></i>
                        </div>
                        <div class="mode-title">Trainingsmodus</div>
                    </div>
                    <div class="mode-description">
                        Ideal zum Lernen und Üben. Erhalte sofortiges Feedback zu deinen Antworten und lerne effektiv.
                    </div>
                    <div class="mode-features">
                        <div class="feature-item">
                            <i class="fas fa-check feature-icon"></i>
                            <span class="feature-text">Detaillierte Auswertung</span>
                        </div>
                        <div class="feature-item">
                            <i class="fas fa-clock feature-icon"></i>
                            <span class="feature-text">Keine Zeitbegrenzung</span>
                        </div>
                        <div class="feature-item">
                            <i class="fas fa-tasks feature-icon"></i>
                            <span class="feature-text">Fortschrittsanzeige</span>
                        </div>
                    </div>
                    <button class="mode-button training">
                        <i class="fas fa-graduation-cap"></i> Trainingsmodus starten
                    </button>
                </div>

                <!-- Prüfungsmodus Karte -->
                <div class="mode-option exam-option">
                    <div class="mode-option-header">
                        <div class="mode-icon">
                            <i class="fas fa-clipboard-check"></i>
                        </div>
                        <div class="mode-title">Prüfungsmodus</div>
                    </div>
                    <div class="mode-description">
                        Bereite dich auf die echte Prüfung vor. Teste dein Wissen unter realistischen
                        Prüfungsbedingungen.
                    </div>
                    <div class="mode-features">
                        <div class="feature-item">
                            <i class="fas fa-chart-bar feature-icon"></i>
                            <span class="feature-text">Feedback am Ende</span>
                        </div>
                        <div class="feature-item">
                            <i class="fas fa-stopwatch feature-icon"></i>
                            <span class="feature-text">Zeitbegrenzung (60 Minuten)</span>
                        </div>
                        <div class="feature-item">
                            <i class="fas fa-graduation-cap feature-icon"></i>
                            <span class="feature-text">Prüfungssimulation</span>
                        </div>
                    </div>
                    <button class="mode-button exam">
                        <i class="fas fa-clipboard-check"></i> Prüfungsmodus starten
                    </button>
                </div>
            </div>
        </div>

        <div class="quiz-content" style="display: none;">
            <div class="quiz-header">


                <!-- Timer Element für den Prüfungsmodus - überarbeitetes Design -->
                <div class="exam-timer"
                    style="display: none; width: 90px; text-align: center; margin: 0 auto 10px auto; padding: 5px; background-color: #1d232b; color: white; border-radius: 3px; font-weight: 500; font-size: 0.9rem; box-shadow: none;">
                    <i class="fas fa-clock"></i> <span class="time-display"
                        style="min-width: 40px; display: inline-block;">00:00</span>
                </div>

                <div class="question-overview">
                    <button class="nav-button prev" id="overview-prev">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <div class="overview-scroll-container">
                        <div id="overview-container"></div>
                    </div>
                    <button class="nav-button next" id="overview-next">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            </div>

            <div class="question-container">
                <!-- Verbesserte Struktur für Fragentext -->
                <div class="question-text-container">
                    <h3 class="question-text"></h3>
                </div>
                <div class="options-container"></div>

                <div class="progress-section">
                    <div class="progress-container">
                        <div class="progress-bar"></div>
                    </div>
                    <div class="progress-info">
                        <!-- Frage-Zähler entfernt -->
                    </div>
                </div>

                <div class="action-buttons">
                    <button class="back-button" title="Zurück">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                    <div class="button-group">
                        <button class="action-button submit-button" title="Quiz beenden">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="action-button mark-button" title="Frage markieren">
                            <i class="fas fa-bookmark"></i>
                        </button>
                        <button class="action-button reset-button" title="Antworten zurücksetzen">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <button class="next-button" title="Weiter">
                        <i class="fas fa-arrow-right"></i>
                    </button>
                </div>
            </div>

            <div class="results-container" style="display: none; margin: 0 auto; box-shadow: none;">
                <h2 class="results-title" style="margin-bottom: 0;">Quiz beendet!</h2>
                <div class="chart-container" style="margin-top: -5px; padding-top: 0;">
                    <canvas id="resultsChart"></canvas>
                </div>
                <p class="results-text"></p>
                <div class="action-buttons cactionbtn"
                    style="display: flex; flex-direction: column; gap: 15px; margin-top: 20px; width: 100%; max-width: 250px;">
                    <button class="filter-button wrong-questions disabled"
                        style="width: 100%; padding: 12px 20px; font-size: 16px; font-weight: 500; border-radius: 4px; border: none; background-color: #6c757d !important; color: #e6e6e6 !important; cursor: not-allowed !important; opacity: 0.65 !important; pointer-events: none !important; text-transform: none;"
                        disabled>
                        <i class="fas fa-times"></i> Falsche Fragen laden
                    </button>
                    <button class="action-button retry-button"
                        style="width: 100%; padding: 12px 20px; font-size: 16px; font-weight: 500; border-radius: 4px; border: none; background-color: #198754; color: white; cursor: pointer; text-transform: none;">
                        <i class="fas fa-redo"></i> Erneut versuchen
                    </button>
                    <button class="action-button switch-mode-button"
                        style="width: 100%; padding: 12px 20px; font-size: 16px; font-weight: 500; border-radius: 4px; border: none; background-color: #1d232b; color: white; cursor: pointer; text-transform: none;">
                        <i class="fas fa-exchange-alt"></i> Modus wechseln
                    </button>
                </div>
                <div class="wrong-answers"></div>
            </div>
            <!-- Mode switch button moved into results container for better organization -->
        </div>
    </div>

    <!-- Modal Container -->
    <div id="quiz-modal" class="modal-container">
        <div class="modal-content">
            <!-- X zum Schließen entfernt -->
            <span class="modal-close" style="display: none;">&times;</span>
            <h2 id="modal-title">Titel</h2>
            <div id="modal-body">
                Inhalt
            </div>
            <div class="modal-footer">
                <button id="modal-confirm" class="modal-button modal-button-primary">
                    <i class="fas fa-check"></i> <span style="text-transform: none !important;">Bestätigen</span>
                </button>
                <button id="modal-cancel" class="modal-button modal-button-secondary">
                    <i class="fas fa-times"></i> <span style="text-transform: none !important;">Abbrechen</span>
                </button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Initialisierung des Quiz
            // Cookie management functions
            const COOKIE_NAMES = {
                MARKED_QUESTIONS: 'squarespace_quiz_marked',
                EXAM_MARKED_QUESTIONS: 'squarespace_quiz_exam_marked',
                USER_ANSWERS: 'squarespace_quiz_answers',
                CURRENT_QUESTION: 'squarespace_quiz_current',
                MODE: 'squarespace_quiz_mode',
                WRONG_QUESTIONS: 'squarespace_quiz_wrong_questions',
                QUIZ_COMPLETED: 'squarespace_quiz_completed',
                ORIGINAL_MARKED_QUESTIONS: 'squarespace_quiz_original_marked',
                ORIGINAL_WRONG_QUESTIONS: 'squarespace_quiz_original_wrong'
            };

            // Verbesserte Persistenz mit Local Storage und Cookies
            function setCookie(name, value, days = 365) {
                // Funktion für markierte Fragen deaktivieren
                if (name === COOKIE_NAMES.MARKED_QUESTIONS ||
                    name === COOKIE_NAMES.EXAM_MARKED_QUESTIONS ||
                    name === COOKIE_NAMES.ORIGINAL_MARKED_QUESTIONS) {
                    // Funktionalität für markierte Fragen vollständig deaktiviert
                    return;
                }

                // Für alle anderen Daten: Cookie setzen mit einem längeren Ablaufdatum (1 Jahr)
                const expires = new Date();
                expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
                document.cookie = `${name}=${encodeURIComponent(JSON.stringify(value))};expires=${expires.toUTCString()};path=/`;

                // Zusätzlich im localStorage speichern für bessere Persistenz
                try {
                    localStorage.setItem(name, JSON.stringify(value));
                } catch (e) {
                    // Warnung entfernt
                }
            }

            function getCookie(name) {
                // Prüfen, ob es sich um ein "marked questions" Cookie handelt
                if (name === COOKIE_NAMES.MARKED_QUESTIONS ||
                    name === COOKIE_NAMES.EXAM_MARKED_QUESTIONS ||
                    name === COOKIE_NAMES.ORIGINAL_MARKED_QUESTIONS) {
                    // Für markierte Fragen werden keine persistenten Daten gespeichert oder abgerufen
                    return null;
                }

                // Für alle anderen Daten:
                // Zuerst versuchen, aus dem localStorage zu lesen
                try {
                    const localData = localStorage.getItem(name);
                    if (localData) {
                        return JSON.parse(localData);
                    }
                } catch (e) {
                    // Warnung entfernt
                }

                // Als Fallback aus Cookies lesen
                const cookies = document.cookie.split(';');
                for (let cookie of cookies) {
                    const [cookieName, cookieValue] = cookie.split('=').map(c => c.trim());
                    if (cookieName === name) {
                        try {
                            return JSON.parse(decodeURIComponent(cookieValue));
                        } catch (e) {
                            // Warnung entfernt
                            return null;
                        }
                    }
                }
                return null;
            }

            // Initialize quiz object
            window.squarespaceQuiz = {
                currentQuestion: 0,
                score: 0,
                userAnswers: [],
                markedQuestions: new Set(),
                examMarkedQuestions: new Set(),
                wrongQuestions: new Set(),
                originalWrongQuestions: new Set(), // Speichert die ursprünglich falschen Fragen
                originalMarkedQuestions: new Set(), // Speichert die ursprünglich markierten Fragen

                isExamMode: false,
                timerStopped: false, // Flag um den Timer gestoppt zu halten nach Moduswechsel
                currentModalContext: null, // Speichert den aktuellen Modal-Kontext ('switchMode', 'timeUp', etc.)
                isFilteredWrongQuestions: false, // Flag für gefilterte falsche Fragen
                isFilteredMarkedQuestions: false, // Flag für gefilterte markierte Fragen
                allQuestions: [], // Store master list of all questions
                questions: [], // Current active questions for the quiz session
                masterQuestions: [
                    {
                        id: "q1",
                        question: "Was ist Squarespace?",
                        options: [
                            { id: "q1_a1", text: "Ein soziales Netzwerk" },
                            { id: "q1_a2", text: "Ein Website-Baukasten und Content-Management-System" },
                            { id: "q1_a3", text: "Ein E-Mail-Marketing-Tool" },
                            { id: "q1_a4", text: "Ein Online-Shop-System" }
                        ],
                        correctOptionId: "q1_a2"
                    },
                    {
                        id: "q2",
                        question: "Welche Art von Templates bietet Squarespace an?",
                        options: [
                            { id: "q2_a1", text: "Nur Blog-Templates" },
                            { id: "q2_a2", text: "Nur Online-Shop-Templates" },
                            { id: "q2_a3", text: "Responsive Templates für verschiedene Branchen und Zwecke" },
                            { id: "q2_a4", text: "Ausschließlich Portfolio-Templates" }
                        ],
                        correctOptionId: "q2_a3"
                    },
                    {
                        id: "q3",
                        question: "Wie können Bilder in Squarespace bearbeitet werden?",
                        options: [
                            { id: "q3_a1", text: "Bilder können nicht bearbeitet werden" },
                            { id: "q3_a2", text: "Nur durch externe Software" },
                            { id: "q3_a3", text: "Nur durch Größenänderung" },
                            { id: "q3_a4", text: "Mit dem integrierten Bildeditor (Zuschneiden, Filter, Anpassungen)" }
                        ],
                        correctOptionId: "q3_a4"
                    },
                    {
                        id: "q4",
                        question: "Welche Funktion bietet Squarespace für SEO?",
                        options: [
                            { id: "q4_a1", text: "Automatische Meta-Beschreibungen und Titel-Tags" },
                            { id: "q4_a2", text: "Keine SEO-Funktionen" },
                            { id: "q4_a3", text: "Nur manuelle Meta-Tags" },
                            { id: "q4_a4", text: "Nur automatische Sitemaps" }
                        ],
                        correctOptionId: "q4_a1"
                    },
                    {
                        id: "q5",
                        question: "Wie können Produkte in einem Squarespace Online-Shop kategorisiert werden?",
                        options: [
                            { id: "q5_a1", text: "Nur durch Tags" },
                            { id: "q5_a2", text: "Nur durch Kategorien" },
                            { id: "q5_a3", text: "Durch Kategorien, Tags und Collections" },
                            { id: "q5_a4", text: "Produkte können nicht kategorisiert werden" }
                        ],
                        correctOptionId: "q5_a3"
                    },
                    {
                        id: "q6",
                        question: "Welche Zahlungsmethoden unterstützt Squarespace standardmäßig?",
                        options: [
                            { id: "q6_a1", text: "Nur PayPal" },
                            { id: "q6_a2", text: "Stripe und PayPal" },
                            { id: "q6_a3", text: "Ausschließlich Kreditkarten" },
                            { id: "q6_a4", text: "Keine integrierte Zahlungsabwicklung" }
                        ],
                        correctOptionId: "q6_a2"
                    },
                    {
                        id: "q7",
                        question: "Was ist eine Squarespace Cover Page?",
                        options: [
                            { id: "q7_a1", text: "Eine temporäre Wartungsseite" },
                            { id: "q7_a2", text: "Eine eigenständige Landing Page" },
                            { id: "q7_a3", text: "Die Startseite einer Website" },
                            { id: "q7_a4", text: "Ein PDF-Download" }
                        ],
                        correctOptionId: "q7_a2"
                    },
                    {
                        id: "q8",
                        question: "Welche Möglichkeiten bietet Squarespace für Blogs?",
                        options: [
                            { id: "q8_a1", text: "Keine Blog-Funktionalität" },
                            { id: "q8_a2", text: "Nur einfache Textbeiträge" },
                            { id: "q8_a3", text: "Umfangreiche Blog-Funktionen mit Kategorien, Tags und Kommentaren" },
                            { id: "q8_a4", text: "Ausschließlich Foto-Blogs" }
                        ],
                        correctOptionId: "q8_a3"
                    },
                    {
                        id: "q9",
                        question: "Wie können Formulare in Squarespace erstellt werden?",
                        options: [
                            { id: "q9_a1", text: "Nur durch externe Plugins" },
                            { id: "q9_a2", text: "Mit dem integrierten Formular-Builder" },
                            { id: "q9_a3", text: "Nur durch HTML-Code" },
                            { id: "q9_a4", text: "Formulare sind nicht möglich" }
                        ],
                        correctOptionId: "q9_a2"
                    },
                    {
                        id: "q10",
                        question: "Was ist Squarespace Analytics?",
                        options: [
                            { id: "q10_a1", text: "Ein externes Analyse-Tool" },
                            { id: "q10_a2", text: "Ein integriertes System zur Besucheranalyse" },
                            { id: "q10_a3", text: "Ein E-Mail-Marketing-Tool" },
                            { id: "q10_a4", text: "Eine Social-Media-Verwaltung" }
                        ],
                        correctOptionId: "q10_a2"
                    },
                    {
                        id: "q11",
                        question: "Welche Mobile-Funktionen bietet Squarespace?",
                        options: [
                            { id: "q11_a1", text: "Keine mobile Optimierung" },
                            { id: "q11_a2", text: "Nur mobile Ansicht" },
                            { id: "q11_a3", text: "Responsive Design und mobile Apps zur Verwaltung" },
                            { id: "q11_a4", text: "Separate mobile Websites" }
                        ],
                        correctOptionId: "q11_a3"
                    },
                    {
                        id: "q12",
                        question: "Wie können in Squarespace Backups erstellt werden?",
                        options: [
                            { id: "q12_a1", text: "Automatische tägliche Backups" },
                            { id: "q12_a2", text: "Manuelle Export-Funktion" },
                            { id: "q12_a3", text: "Keine Backup-Möglichkeit" },
                            { id: "q12_a4", text: "Nur durch Drittanbieter" }
                        ],
                        correctOptionId: "q12_a2"
                    },
                    {
                        id: "q13",
                        question: "Was ist Squarespace Email Campaigns?",
                        options: [
                            { id: "q13_a1", text: "Ein externes Newsletter-Tool" },
                            { id: "q13_a2", text: "Eine integrierte E-Mail-Marketing-Lösung" },
                            { id: "q13_a3", text: "Ein Support-Ticketsystem" },
                            { id: "q13_a4", text: "Ein Spam-Filter" }
                        ],
                        correctOptionId: "q13_a2"
                    },
                    {
                        id: "q14",
                        question: "Welche Social Media Integration bietet Squarespace?",
                        options: [
                            { id: "q14_a1", text: "Keine Integration möglich" },
                            { id: "q14_a2", text: "Nur Facebook" },
                            { id: "q14_a3", text: "Umfassende Integration verschiedener Plattformen" },
                            { id: "q14_a4", text: "Nur durch Plugins" }
                        ],
                        correctOptionId: "q14_a3"
                    },
                    {
                        id: "q15",
                        question: "Wie können Domains in Squarespace verwaltet werden?",
                        options: [
                            { id: "q15_a1", text: "Nur externe Domains" },
                            { id: "q15_a2", text: "Keine Domain-Verwaltung" },
                            { id: "q15_a3", text: "Integrierte Domain-Registrierung und -Verwaltung" },
                            { id: "q15_a4", text: "Nur Squarespace-Subdomains" }
                        ],
                        correctOptionId: "q15_a3"
                    },
                    {
                        id: "q16",
                        question: "Was sind Squarespace Extensions?",
                        options: [
                            { id: "q16_a1", text: "Externe Plugins" },
                            { id: "q16_a2", text: "Design-Vorlagen" },
                            { id: "q16_a3", text: "Integrierte Zusatzfunktionen für E-Commerce" },
                            { id: "q16_a4", text: "Blog-Kategorien" }
                        ],
                        correctOptionId: "q16_a3"
                    },
                    {
                        id: "q17",
                        question: "Welche Möglichkeiten bietet Squarespace für mehrsprachige Websites?",
                        options: [
                            { id: "q17_a1", text: "Keine Mehrsprachigkeit möglich" },
                            { id: "q17_a2", text: "Automatische Übersetzung" },
                            { id: "q17_a3", text: "Manuelle Erstellung mehrsprachiger Seiten" },
                            { id: "q17_a4", text: "Nur englische Sprache" }
                        ],
                        correctOptionId: "q17_a3"
                    },
                    {
                        id: "q18",
                        question: "Was ist der Squarespace Circle?",
                        options: [
                            { id: "q18_a1", text: "Ein Social Network" },
                            { id: "q18_a2", text: "Eine Community für Squarespace-Entwickler" },
                            { id: "q18_a3", text: "Ein Newsletter" },
                            { id: "q18_a4", text: "Ein Kundenservice-Portal" }
                        ],
                        correctOptionId: "q18_a2"
                    },
                    {
                        id: "q19",
                        question: "Welche CSS-Anpassungen erlaubt Squarespace?",
                        options: [
                            { id: "q19_a1", text: "Keine CSS-Anpassungen" },
                            { id: "q19_a2", text: "Nur vordefinierte Styless" },
                            { id: "q19_a3", text: "Vollständige CSS-Kontrolle durch Custom CSS" },
                            { id: "q19_a4", text: "Nur Farbänderungen" }
                        ],
                        correctOptionId: "q19_a3"
                    },
                    {
                        id: "q20",
                        question: "Was ist der Squarespace Developer Mode?",
                        options: [
                            { id: "q20_a1", text: "Ein Debugging-Tool" },
                            { id: "q20_a2", text: "Eine Entwicklungsumgebung für fortgeschrittene Anpassungen" },
                            { id: "q20_a3", text: "Ein Template-Editor" },
                            { id: "q20_a4", text: "Ein Support-Bereich" }
                        ],
                        correctOptionId: "q20_a2"
                    },
                    {
                        id: "q21",
                        question: "Welche SEO-Tools bietet Squarespace für Bilder?",
                        options: [
                            { id: "q21_a1", text: "Automatische Alt-Text-Generierung" },
                            { id: "q21_a2", text: "Manuelle Alt-Text-Eingabe und Bildtitel" },
                            { id: "q21_a3", text: "Keine SEO-Optimierung für Bilder" },
                            { id: "q21_a4", text: "Nur Dateinamen-Optimierung" }
                        ],
                        correctOptionId: "q21_a2"
                    },
                    {
                        id: "q22",
                        question: "Was ist Squarespace Scheduling?",
                        options: [
                            { id: "q22_a1", text: "Ein Blog-Planungstool" },
                            { id: "q22_a2", text: "Ein Terminbuchungssystem" },
                            { id: "q22_a3", text: "Ein Social Media Planer" },
                            { id: "q22_a4", text: "Ein Newsletter-Zeitplaner" }
                        ],
                        correctOptionId: "q22_a2"
                    },
                    {
                        id: "q23",
                        question: "Welche Video-Hosting-Optionen unterstützt Squarespace?",
                        options: [
                            { id: "q23_a1", text: "Nur YouTube" },
                            { id: "q23_a2", text: "Nur Vimeo" },
                            { id: "q23_a3", text: "YouTube, Vimeo und native Video-Uploads" },
                            { id: "q23_a4", text: "Keine Video-Integration" }
                        ],
                        correctOptionId: "q23_a3"
                    },
                    {
                        id: "q24",
                        question: "Was sind Squarespace Blocks?",
                        options: [
                            { id: "q24_a1", text: "Werbeblöcke" },
                            { id: "q24_a2", text: "Vordefinierte Layout-Elemente" },
                            { id: "q24_a3", text: "Social Media Widgets" },
                            { id: "q24_a4", text: "Plugin-Systeme" }
                        ],
                        correctOptionId: "q24_a2"
                    },
                    {
                        id: "q25",
                        question: "Wie funktioniert das Squarespace Mitgliederbereich-System?",
                        options: [
                            { id: "q25_a1", text: "Ist nicht verfügbar" },
                            { id: "q25_a2", text: "Nur für Newsletter" },
                            { id: "q25_a3", text: "Passwortgeschützte Bereiche und Mitglieder-Management" },
                            { id: "q25_a4", text: "Nur für Administratoren" }
                        ],
                        correctOptionId: "q25_a3"
                    }
                ],

                initializeQuestions: function () {
                    // Store full question set if not already stored
                    if (this.allQuestions.length === 0) {
                        this.allQuestions = JSON.parse(JSON.stringify(this.masterQuestions));
                    }

                    if (this.isExamMode) {
                        // For exam mode, randomly select 100 questions from the question pool
                        const shuffled = [...this.allQuestions].sort(() => 0.5 - Math.random());
                        this.questions = shuffled.slice(0, 100);
                    } else {
                        // For training mode, also randomize questions just like in exam mode
                        const shuffled = [...this.allQuestions].sort(() => 0.5 - Math.random());
                        this.questions = shuffled;
                    }

                    // Initialize answer array based on number of questions
                    this.userAnswers = new Array(this.questions.length).fill(null);
                },

                loadMarkedQuestions: function () {
                    // Verbesserte und robustere Funktion zum Laden markierter Fragen mit besserer Persistenz
                    // Log entfernt

                    // Die Cookie-Funktionalität für markierte Fragen wurde deaktiviert
                    // Initialisiere leere Arrays für die markierten Fragen
                    const markedFromCookie = [];
                    const examMarkedFromCookie = [];
                    const originalMarkedFromCookie = [];
                    const quizCompleted = getCookie(COOKIE_NAMES.QUIZ_COMPLETED);

                    // Daten aus persistentem Speicher geladen

                    // Wichtig: Initialisiere die Sets, falls sie noch nicht existieren
                    if (!this.markedQuestions) this.markedQuestions = new Set();
                    if (!this.originalMarkedQuestions) this.originalMarkedQuestions = new Set();
                    if (!this.examMarkedQuestions) this.examMarkedQuestions = new Set();

                    // Klare Prioritätsstruktur für markierte Fragen:

                    // 1. Prüfe, ob originalMarkedQuestions existieren (höchste Priorität)
                    if (originalMarkedFromCookie && originalMarkedFromCookie.length > 0) {
                        // Stelle sicher, dass beide Sets konsistent sind
                        this.originalMarkedQuestions = new Set(originalMarkedFromCookie);
                        this.markedQuestions = new Set(originalMarkedFromCookie);

                        // Markierte Fragen benötigen keine Cookie-Persistenz
                        // setCookie für markierte Fragen entfernt
                        // Markierte Fragen aus originalMarkedQuestions geladen
                    }
                    // 2. Wenn keine originalMarkedQuestions existieren, aber reguläre markedQuestions
                    else if (markedFromCookie && markedFromCookie.length > 0) {
                        this.markedQuestions = new Set(markedFromCookie);

                        // Erstelle originalMarkedQuestions aus markedQuestions für Konsistenz
                        this.originalMarkedQuestions = new Set(markedFromCookie);
                        // Cookie-Funktionalität für markierte Fragen wurde deaktiviert
                        // setCookie-Aufruf für markierte Fragen entfernt
                    }
                    // 3. Falls das Quiz abgeschlossen wurde und keine markierten Fragen gefunden wurden,
                    // versuche, originalMarkedQuestions neu zu erstellen (nützlich nach Abschluss)
                    else if (quizCompleted) {

                        // Stelle sicher, dass markedQuestions und originalMarkedQuestions synchron sind
                        if (this.originalMarkedQuestions && this.originalMarkedQuestions.size > 0) {
                            this.markedQuestions = new Set(this.originalMarkedQuestions);

                            // Cookie-Funktionalität für markierte Fragen wurde deaktiviert
                            // setCookie-Aufrufe für markierte Fragen entfernt
                        }
                    }

                    // Lade die Prüfungsmodus-markierten Fragen unabhängig (keine Abhängigkeit von den anderen)
                    if (examMarkedFromCookie && examMarkedFromCookie.length > 0) {
                        this.examMarkedQuestions = new Set(examMarkedFromCookie);
                        // Log entfernt
                    }

                    // Aktualisiere die UI-Elemente, die markierte Fragen anzeigen
                    this.updateQuestionIndicators();
                    this.updateFilterButtons();
                },

                // Diese Funktion wurde entfernt, weil sie doppelt definiert war.
                // Wir verwenden jetzt nur noch die zweite Definition der updateQuestionIndicators-Funktion
                // (die später im Code definiert ist)
                updateQuestionIndicators: function () {
                    console.log("UMGELEITET - wir verwenden die andere updateQuestionIndicators-Funktion");
                    return;
                },

                saveMarkedQuestions: function () {
                    // Cookie-Funktionalität für markierte Fragen deaktiviert
                    // Die markierten Fragen werden nur im Speicher gehalten, 
                    // aber nicht als Cookies gespeichert
                },

                toggleMarkQuestion: function (questionIndex) {
                    // Debug-Ausgabe für die Nachverfolgung
                    console.log("toggleMarkQuestion aufgerufen mit Index:", questionIndex);

                    // Aktuelle Frage holen, um die ID zu bekommen
                    let currentQuestion = this.questions[questionIndex];

                    // Sicherstellen, dass die Frage eine ID hat
                    if (!currentQuestion || !currentQuestion.id) {
                        console.error("Frage hat keine ID oder existiert nicht:", questionIndex);
                        return;
                    }

                    // Die eindeutige Frage-ID verwenden
                    let questionId = currentQuestion.id;
                    console.log("Toggle-Markierung für Frage mit ID:", questionId);

                    // Initialisieren aller Sets, falls noch nicht vorhanden
                    if (!this.markedQuestions) this.markedQuestions = new Set();
                    if (!this.examMarkedQuestions) this.examMarkedQuestions = new Set();
                    if (!this.originalMarkedQuestions) this.originalMarkedQuestions = new Set();

                    // WICHTIG: Drucke alle aktuellen IDs in den Sets aus
                    console.log("VOR dem Toggle - markedQuestions:", Array.from(this.markedQuestions));
                    console.log("VOR dem Toggle - examMarkedQuestions:", Array.from(this.examMarkedQuestions));
                    console.log("VOR dem Toggle - originalMarkedQuestions:", Array.from(this.originalMarkedQuestions));

                    // Prüfen ob die Frage bereits markiert ist
                    const isMarked = this.isQuestionMarked(questionId);
                    console.log("Ist die Frage bereits markiert?", isMarked);

                    // Das Set auswählen, das wir aktualisieren möchten
                    const targetSet = this.isExamMode ? this.examMarkedQuestions : this.markedQuestions;

                    if (isMarked) {
                        // NUR diese spezifische Frage aus den Sets entfernen
                        console.log("Entferne Markierung für ID:", questionId);
                        // Entferne nur die exakte ID aus jedem Set
                        targetSet.delete(questionId);
                        this.originalMarkedQuestions.delete(questionId);
                    } else {
                        // Frage zum Set hinzufügen
                        console.log("Füge Markierung hinzu für ID:", questionId);
                        targetSet.add(questionId);
                        this.originalMarkedQuestions.add(questionId);
                    }

                    // WICHTIG: Drucke alle aktualisierten IDs in den Sets aus
                    console.log("NACH dem Toggle - markedQuestions:", Array.from(this.markedQuestions));
                    console.log("NACH dem Toggle - examMarkedQuestions:", Array.from(this.examMarkedQuestions));
                    console.log("NACH dem Toggle - originalMarkedQuestions:", Array.from(this.originalMarkedQuestions));

                    // UI-Elemente aktualisieren - aber keine komplette Übersicht neu rendern
                    // Dadurch verhindern wir, dass die UI-Aktualisierung andere Fragen beeinflusst
                    this.updateMarkButton();

                    // Nur die Indikator-Klasse der aktuellen Frage aktualisieren
                    const indicators = document.querySelectorAll('.question-indicator');
                    if (indicators && indicators.length > questionIndex) {
                        const indicator = indicators[questionIndex];
                        if (indicator) {
                            // Klasse basierend auf dem neuen Markierungsstatus setzen
                            const newIsMarked = !isMarked;
                            if (newIsMarked) {
                                indicator.classList.add('marked');
                            } else {
                                indicator.classList.remove('marked');
                            }
                            console.log("Indikator-Klassen aktualisiert für Frage", questionIndex);
                        }
                    }
                },

                isQuestionMarked: function (questionIdOrIndex) {
                    console.log("isQuestionMarked aufgerufen mit:", questionIdOrIndex, "Typ:", typeof questionIdOrIndex);

                    // Initialisiere alle Sets
                    if (!this.markedQuestions) this.markedQuestions = new Set();
                    if (!this.examMarkedQuestions) this.examMarkedQuestions = new Set();
                    if (!this.originalMarkedQuestions) this.originalMarkedQuestions = new Set();

                    // Jetzt unterstützen wir sowohl IDs als auch Indizes
                    let questionId = questionIdOrIndex;

                    // Wenn ein Index übergeben wurde (für Rückwärtskompatibilität), 
                    // konvertieren wir zu einer ID
                    if (typeof questionIdOrIndex === 'number') {
                        console.log("Index wurde übergeben, konvertiere zu ID...");

                        // Versuchen, die Frage in questions zu finden
                        const question = this.questions[questionIdOrIndex];
                        if (question && question.id) {
                            questionId = question.id;
                            console.log("Konvertiert zu ID:", questionId, "aus questions");
                        } else {
                            // Versuchen, die Frage in allQuestions zu finden
                            const allQuestion = this.allQuestions && this.allQuestions[questionIdOrIndex];
                            if (allQuestion && allQuestion.id) {
                                questionId = allQuestion.id;
                                console.log("Konvertiert zu ID:", questionId, "aus allQuestions");
                            } else {
                                console.warn("Keine Frage für Index gefunden:", questionIdOrIndex);
                            }
                        }
                    }

                    // Prüfe direkt alle Sets mit der ID
                    const mainMarked = this.markedQuestions.has(questionId);
                    const examMarked = this.examMarkedQuestions.has(questionId);
                    const originalMarked = this.originalMarkedQuestions.has(questionId);

                    console.log("Set-Prüfung für ID:", questionId);
                    console.log("- markedQuestions hat ID:", mainMarked);
                    console.log("- examMarkedQuestions hat ID:", examMarked);
                    console.log("- originalMarkedQuestions hat ID:", originalMarked);

                    // Eine Frage gilt als markiert, wenn sie in irgendeinem Set vorkommt
                    const isMarked = mainMarked || examMarked || originalMarked;
                    console.log("Markierungsstatus:", isMarked);

                    return isMarked;
                },


                startQuiz: function (examMode) {
                    // Log für Debugging bei Initialisierung
                    console.log("startQuiz wird aufgerufen - Modus:", examMode ? "Prüfung" : "Training");

                    // Setze den Modus
                    this.isExamMode = examMode;

                    // Sichere Initialisierung aller Sets
                    if (!this.markedQuestions) this.markedQuestions = new Set();
                    if (!this.examMarkedQuestions) this.examMarkedQuestions = new Set();
                    if (!this.originalMarkedQuestions) this.originalMarkedQuestions = new Set();

                    // Store original marked questions when switching modes
                    const originalMarkedQuestions = new Set(this.markedQuestions);
                    const originalExamMarkedQuestions = new Set(this.examMarkedQuestions);

                    // Store wrong questions
                    const savedQuizCompleted = getCookie(COOKIE_NAMES.QUIZ_COMPLETED);
                    const savedWrongQuestions = getCookie(COOKIE_NAMES.WRONG_QUESTIONS);
                    const hasWrongQuestions = savedWrongQuestions && savedWrongQuestions.length > 0;
                    const wasQuizCompleted = savedQuizCompleted === true;

                    // Sicherstellen, dass Fragen initialisiert werden
                    try {
                        this.initializeQuestions();
                        console.log("Fragen initialisiert - Anzahl:", this.questions ? this.questions.length : 0);
                    } catch (e) {
                        console.error("Fehler bei der Initialisierung der Fragen:", e);
                    }

                    this.resetQuiz();

                    // Restore marked questions after reset
                    if (!examMode) {
                        this.markedQuestions = originalMarkedQuestions;

                        // Wenn ein Quiz abgeschlossen wurde und falsche Fragen gespeichert wurden,
                        // dann lade diese in die wrongQuestions-Variable
                        // Falsche Fragen sollen sich immer auf den letzten Test aus dem aktiven Modus beziehen
                        if (hasWrongQuestions) {
                            this.wrongQuestions = new Set(savedWrongQuestions);
                        }
                    } else {
                        this.examMarkedQuestions = originalExamMarkedQuestions;
                    }

                    // Show quiz content and hide mode selection
                    const modeSelection = document.querySelector('.mode-selection');
                    const quizContent = document.querySelector('.quiz-content');
                    if (modeSelection && quizContent) {
                        modeSelection.style.display = 'none';
                        quizContent.style.display = 'block';
                    }

                    // Exam mode handling
                    // Exam mode handling
                    // Wir verwenden nur den 10-Sekunden-Timer in startQuestionTimer
                    // und zeigen keinen Timer im Trainingsmodus

                    if (examMode) {
                        // Im Prüfungsmodus wird der Timer über startQuestionTimer gesteuert
                        // Der Timer wird in loadQuestion automatisch gestartet
                    } else {
                        // Verstecke Timer im Trainingsmodus
                        const examTimer = document.querySelector('.exam-timer');
                        if (examTimer) examTimer.style.display = 'none';
                    }

                    this.loadQuestion();
                    this.updateQuestionOverview();
                },

                // Hilfsfunktion, um die Hervorhebung in der Navigation zu korrigieren
                fixNavigationHighlighting: function () {
                    // Entferne die 'current' Klasse von allen Fragenindikatoren
                    document.querySelectorAll('.question-indicator').forEach(indicator => {
                        indicator.classList.remove('current');
                    });

                    // Füge die 'current' Klasse nur zum Indikator der aktuellen Frage hinzu
                    document.querySelectorAll('.question-indicator').forEach(indicator => {
                        const indicatorIndex = parseInt(indicator.textContent) - 1; // Da die Anzeige bei 1 beginnt
                        if (indicatorIndex === this.currentQuestion) {
                            indicator.classList.add('current');
                        }
                    });
                },

                updateQuestionOverview: function () {
                    // Diese Funktion würde normalerweise die Hervorhebung automatisch korrigieren,
                    // aber in manchen Fällen funktioniert das nicht wie erwartet.
                    // Log entfernt;

                    const container = document.getElementById('overview-container');
                    if (!container) return;

                    container.innerHTML = '';

                    // Bestimme die Anzahl der anzuzeigenden Fragen (max 10 normal, max 5 mobil)
                    const totalQuestions = this.questions.length;

                    // Ermittle, ob die mobile Ansicht aktiv ist
                    const isMobile = window.innerWidth <= 768;
                    const blockSize = isMobile ? 5 : 10;

                    // Berechne den aktuellen Block basierend auf der aktuellen Frage
                    const currentBlock = Math.floor(this.currentQuestion / blockSize);

                    // Berechne Start- und Endindex für die sichtbaren Fragen
                    let startIndex, endIndex;

                    if (this.isFilteredWrongQuestions) {
                        // Bei falschen Fragen: Wir müssen mit Blöcken arbeiten, damit die Navigation funktioniert
                        // Berechne den aktuellen Block basierend auf der aktuellen Frage
                        const wrongQuestionsBlock = Math.floor(this.currentQuestion / blockSize);

                        // Berechne Start- und Endindex für die sichtbaren Fragen
                        startIndex = wrongQuestionsBlock * blockSize;
                        endIndex = Math.min(totalQuestions, startIndex + blockSize);

                        // Stelle sicher, dass die aktuelle Frage im angezeigten Block ist
                        if (this.currentQuestion < startIndex || this.currentQuestion >= endIndex) {
                            // Wenn die aktuelle Frage nicht im angezeigten Block ist, 
                            // berechne den richtigen Block neu
                            const newBlock = Math.floor(this.currentQuestion / blockSize);
                            startIndex = newBlock * blockSize;
                            endIndex = Math.min(totalQuestions, startIndex + blockSize);
                        }
                    } else {
                        // Im normalen Modus: übliche Blocknavigation
                        startIndex = currentBlock * blockSize;
                        endIndex = Math.min(totalQuestions, startIndex + blockSize);
                    }

                    // Log entfernt;

                    // Erstelle die sichtbaren Fragen-Indikatoren
                    for (let i = startIndex; i < endIndex; i++) {
                        const indicator = document.createElement('div');
                        indicator.className = 'question-indicator';
                        indicator.textContent = (i + 1).toString();

                        // Setze den Originalindex für diese Frage (für korrekte Markierung und Beantwortung)
                        // Wenn wir in einem gefilterten Modus sind und questionIndices existiert, verwende diese
                        const originalIndex = (this.questionIndices && this.questionIndices[i] !== undefined)
                            ? this.questionIndices[i]
                            : i;

                        // Speichere den Originalindex als Dateneigenschaft für Debug-Zwecke
                        indicator.dataset.originalIndex = originalIndex;

                        // Add classes for different states - Aktuelle Frage nur markieren, wenn es genau diese Frage ist
                        // Bei falschen Fragen werden wir die Markierung später mit fixNavigationHighlighting korrigieren
                        if (i === this.currentQuestion) {
                            indicator.classList.add('current');
                        }

                        // NEUE LOGIK FÜR DIE FALSCH-BEANTWORTETEN FRAGEN

                        // 1. Im Modus für markierte Fragen - WIR ÄNDERN DIE LOGIK:
                        if (this.isFilteredMarkedQuestions) {
                            // Wir müssen jetzt die ID der Frage ermitteln, um zu prüfen, ob sie markiert ist
                            const question = this.questions[i];
                            if (!question || !question.id) {
                                console.warn("Frage hat keine ID für Index:", i);
                                continue; // Überspringen, wenn die Frage keine ID hat
                            }

                            // Prüfen, ob die Frage-ID in originalMarkedQuestions vorhanden ist
                            const isStillMarked = this.originalMarkedQuestions &&
                                this.originalMarkedQuestions.has(question.id);

                            console.log("Frage", i, "mit ID", question.id, "markiert?", isStillMarked);

                            // Nur wenn die Frage immer noch markiert ist, fügen wir die Klasse hinzu
                            if (isStillMarked) {
                                indicator.classList.add('marked');

                                // Status der Antworten mit speziellen Klassen anzeigen (grüner/roter Rand)
                                if (this.userAnswers[i] !== null) {
                                    if (this.userAnswers[i] === this.questions[i].correct) {
                                        indicator.classList.add('marked-correct');
                                    } else {
                                        indicator.classList.add('marked-incorrect');
                                    }
                                }
                            } else {
                                // Wenn die Frage nicht mehr markiert ist, entferne die Klasse
                                indicator.classList.remove('marked');

                                // Antwort-Status ohne Markierung anzeigen
                                if (this.userAnswers[i] !== null) {
                                    if (this.userAnswers[i] === this.questions[i].correct) {
                                        indicator.classList.add('correct');
                                    } else {
                                        indicator.classList.add('incorrect');
                                    }
                                }
                            }
                        }
                        // 2. Im Modus für falsche Fragen:
                        else if (this.isFilteredWrongQuestions) {
                            // Prüfen, ob die Frage markiert ist, um ihre Markierung beizubehalten
                            let shouldBeMarked = false;

                            // Wir müssen die ID der Frage ermitteln, um zu prüfen, ob sie markiert ist
                            const question = this.questions[i];
                            if (!question || !question.id) {
                                console.warn("Frage hat keine ID für Index:", i);
                                continue; // Überspringen, wenn die Frage keine ID hat
                            }

                            // Im falsche-Fragen-Modus: Prüfe, ob die Frage-ID in originalMarkedQuestions ist
                            if (this.originalMarkedQuestions && this.originalMarkedQuestions.has(question.id)) {
                                indicator.classList.add('marked');
                                shouldBeMarked = true;
                                console.log("Falsche Frage", i, "mit ID", question.id, "ist markiert");
                            }

                            // Dann Antwort-Status hinzufügen, aber NUR bei nicht-markierten Fragen
                            if (this.userAnswers[i] !== null) {
                                if (shouldBeMarked) {
                                    // Markierte Fragen behalten orange Farbe, bekommen aber Rahmen für richtig/falsch
                                    // Verbesserte Korrektheitsprüfung mit ID-Methode, falls verfügbar
                                    let isCorrect = false;

                                    if (this.questions[i].correctOptionId && this.userAnswers[i] !== null) {
                                        // ID-basierte Methode: Prüfe, ob die ID der gewählten Option mit correctOptionId übereinstimmt
                                        const selectedOption = this.questions[i].options[this.userAnswers[i]];
                                        isCorrect = selectedOption && selectedOption.id === this.questions[i].correctOptionId;
                                    } else {
                                        // Fallback auf index-basierte Methode
                                        isCorrect = this.userAnswers[i] === this.questions[i].correct;
                                    }

                                    if (isCorrect) {
                                        indicator.classList.add('marked-correct');
                                    } else {
                                        indicator.classList.add('marked-incorrect');
                                    }
                                } else {
                                    // Nicht-markierte Fragen werden grün/rot je nach Antwort
                                    // Verbesserte Korrektheitsprüfung mit ID-Methode, falls verfügbar
                                    let isCorrect = false;

                                    if (this.questions[i].correctOptionId && this.userAnswers[i] !== null) {
                                        // ID-basierte Methode: Prüfe, ob die ID der gewählten Option mit correctOptionId übereinstimmt
                                        const selectedOption = this.questions[i].options[this.userAnswers[i]];
                                        isCorrect = selectedOption && selectedOption.id === this.questions[i].correctOptionId;
                                    } else {
                                        // Fallback auf index-basierte Methode
                                        isCorrect = this.userAnswers[i] === this.questions[i].correct;
                                    }

                                    if (isCorrect) {
                                        indicator.classList.add('correct');
                                    } else {
                                        indicator.classList.add('incorrect');
                                    }
                                }
                            }
                        }
                        // 3. Normaler Modus:
                        else {
                            // Wir müssen die Frage-ID verwenden um zu prüfen, ob sie markiert ist
                            const question = this.questions[i];
                            if (!question || !question.id) {
                                console.warn("Frage hat keine ID für Index:", i);
                                continue; // Überspringen, wenn die Frage keine ID hat
                            }

                            // Prüfen, ob die Frage anhand ihrer ID markiert ist
                            const isMarked = this.isQuestionMarked(question.id);
                            console.log("Normale Frage", i, "mit ID", question.id, "markiert?", isMarked);

                            if (isMarked) {
                                indicator.classList.add('marked');
                            }

                            // Dann Antwort-Status hinzufügen
                            if (this.userAnswers[i] !== null) {
                                // Im Prüfungsmodus: Alle beantworteten Fragen werden GRAU angezeigt ohne Feedback
                                if (this.isExamMode) {
                                    // Markierung hat Vorrang
                                    if (isMarked) {
                                        // Markierte Fragen bleiben gelb, auch im Prüfungsmodus
                                        // Standardklasse 'marked' bereits hinzugefügt, keine weitere nötig
                                    } else {
                                        // Im Prüfungsmodus werden beantwortete Fragen grau, nie rot oder grün
                                        indicator.classList.add('answered');
                                    }
                                } else {
                                    // TRAININGSMODUS - hier bleibt die bestehende Logik mit Feedback erhalten
                                    if (isMarked) {
                                        // Markierte Fragen behalten orange Farbe, bekommen aber Rahmen
                                        // Verbesserte Korrektheitsprüfung mit ID-Methode, falls verfügbar
                                        let isCorrect = false;

                                        if (this.questions[i].correctOptionId && this.userAnswers[i] !== null) {
                                            // ID-basierte Methode: Prüfe, ob die ID der gewählten Option mit correctOptionId übereinstimmt
                                            const selectedOption = this.questions[i].options[this.userAnswers[i]];
                                            isCorrect = selectedOption && selectedOption.id === this.questions[i].correctOptionId;
                                        } else {
                                            // Fallback auf index-basierte Methode
                                            isCorrect = this.userAnswers[i] === this.questions[i].correct;
                                        }

                                        if (isCorrect) {
                                            indicator.classList.add('marked-correct');
                                        } else {
                                            indicator.classList.add('marked-incorrect');
                                        }
                                    } else {
                                        // Nicht-markierte Fragen werden grün/rot
                                        // Verbesserte Korrektheitsprüfung mit ID-Methode, falls verfügbar
                                        let isCorrect = false;

                                        if (this.questions[i].correctOptionId && this.userAnswers[i] !== null) {
                                            // ID-basierte Methode: Prüfe, ob die ID der gewählten Option mit correctOptionId übereinstimmt
                                            const selectedOption = this.questions[i].options[this.userAnswers[i]];
                                            isCorrect = selectedOption && selectedOption.id === this.questions[i].correctOptionId;
                                        } else {
                                            // Fallback auf index-basierte Methode
                                            isCorrect = this.userAnswers[i] === this.questions[i].correct;
                                        }

                                        if (isCorrect) {
                                            indicator.classList.add('correct');
                                        } else {
                                            indicator.classList.add('incorrect');
                                        }
                                    }
                                }
                            }
                        }

                        indicator.addEventListener('click', () => {
                            // Hier den Originalindex verwenden statt des Schleifenindex i
                            // Das sorgt dafür, dass die richtige Frage geladen wird, wenn die Reihenfolge geändert wurde
                            this.currentQuestion = originalIndex;

                            // WICHTIG: Wenn wir im Modus für falsche Fragen sind und auf eine Nummer klicken,
                            // müssen wir NUR die Frage ändern, aber im Modus für falsche Fragen bleiben
                            if (this.isFilteredWrongQuestions) {
                                // Wir bleiben im Modus für falsche Fragen, ändern nur die aktuelle Frage
                                this.currentQuestion = i; // Verwende den lokalen Index in der gefilterten Liste
                            }

                            this.loadQuestion();
                            this.updateQuestionOverview();
                        });

                        container.appendChild(indicator);
                    }

                    // Aktualisiere die Fortschrittsanzeige
                    const progressBar = document.querySelector('.progress-bar');
                    if (progressBar) {
                        const answered = this.userAnswers.filter(answer => answer !== null).length;
                        const correct = this.userAnswers.reduce((count, answer, index) => {
                            const question = this.questions[index];
                            let isCorrect = false;

                            if (question.correctOptionId && answer !== null) {
                                // ID-basierte Methode: Prüfe, ob die ID der gewählten Option mit correctOptionId übereinstimmt
                                const selectedOption = question.options[answer];
                                isCorrect = selectedOption && selectedOption.id === question.correctOptionId;
                            } else {
                                // Fallback auf index-basierte Methode
                                isCorrect = answer === question.correct;
                            }

                            return count + (isCorrect ? 1 : 0);
                        }, 0);

                        progressBar.style.setProperty('--answered-percentage', `${(answered / this.questions.length) * 100}%`);
                        progressBar.style.setProperty('--correct-percentage', `${(correct / this.questions.length) * 100}%`);

                        // Entferne zuerst alle Modus-Klassen
                        progressBar.classList.remove('training-mode', 'exam-mode');

                        // Füge entsprechende Klasse hinzu, je nach Prüfungsmodus
                        if (this.isExamMode) {
                            progressBar.classList.add('exam-mode');
                        } else {
                            progressBar.classList.add('training-mode');
                        }
                    }

                    // Aktualisiere den Status der Filter-Buttons
                    const wrongButton = document.querySelector('.filter-button.wrong-questions');
                    if (wrongButton) {
                        wrongButton.disabled = this.wrongQuestions.size === 0;
                    }
                },
                resetQuiz: function () {
                    // Log entfernt
                    this.currentQuestion = 0;
                    this.score = 0;
                    this.userAnswers = new Array(this.questions.length).fill(null);

                    // Zurücksetzen der gespeicherten Reihenfolge der Antwortoptionen
                    // Dadurch werden die Antworten bei einem neuen Quiz erneut gemischt
                    this.currentShuffledIndices = {};

                    // WICHTIGE ÄNDERUNG: Markierungen immer zurücksetzen beim Neustart, wie beim ersten Laden
                    // Dies stellt sicher, dass der Neustart des Quiz genau wie das erste Laden funktioniert
                    this.markedQuestions.clear();
                    this.examMarkedQuestions.clear();
                    this.originalMarkedQuestions.clear();

                    // BUGFIX: Reset der falschen Fragen zwischen Sessions
                    // Vorher: Die falschen Fragen wurden zwischen Sessions beibehalten, was zu Caching-Problemen führte
                    // Jetzt: Wir setzen die falschen Fragen vollständig zurück, es sei denn, wir sind im falschen Fragen Modus
                    if (!this.isFilteredWrongQuestions) {
                        // Die Sammlung der falschen Fragen komplett zurücksetzen
                        this.wrongQuestions = new Set();
                        this.originalWrongQuestions = new Set();
                        // Log entfernt

                        // KRITISCHE BUGFIX: Globales Array aktuelleTestFalscheIndizes leeren und im localStorage löschen
                        // Dies ist die Hauptursache für persistente falsche Fragen zwischen Sessions
                        if (window.aktuelleTestFalscheIndizes) {
                            window.aktuelleTestFalscheIndizes = [];
                            // Log entfernt
                        }

                        // Globales localStorage-Item löschen
                        try {
                            localStorage.removeItem('aktuelleTestFalscheIndizes');
                            // Log entfernt
                        } catch (e) {
                            // Warnung entfernt
                        }

                        // Cookies für falsche Fragen löschen (auch die originalen falschen Fragen)
                        setCookie(COOKIE_NAMES.WRONG_QUESTIONS, []);
                        setCookie(COOKIE_NAMES.ORIGINAL_WRONG_QUESTIONS, []);

                        // Zusätzlich aus localStorage löschen für vollständige Bereinigung
                        try {
                            localStorage.removeItem(COOKIE_NAMES.WRONG_QUESTIONS);
                            localStorage.removeItem(COOKIE_NAMES.ORIGINAL_WRONG_QUESTIONS);
                            // Log entfernt
                        } catch (e) {
                            // Warnung entfernt
                        }
                    } else {
                        // Wenn wir aus dem falschen Fragen Modus zurückkehren, nichts löschen
                        // Log entfernt
                    }

                    this.quizCompleted = false; // Wichtig: Setze den Status zurück
                    this.isFilteredWrongQuestions = false; // Setze den Modus für falsche Fragen zurück
                    this.isFilteredMarkedQuestions = false; // Setze den Modus für markierte Fragen zurück

                    // Reset UI elements
                    const resultsContainer = document.querySelector('.results-container');
                    const questionContainer = document.querySelector('.question-container');
                    const questionOverview = document.querySelector('.question-overview');

                    // Entferne alle "Test abgeschlossen" Elemente
                    const testCompletedHeading = document.querySelector('.test-completed-heading');
                    if (testCompletedHeading) {
                        testCompletedHeading.remove();
                    }

                    if (resultsContainer) resultsContainer.style.display = 'none';
                    if (questionContainer) questionContainer.style.display = 'block';
                    if (questionOverview) questionOverview.style.display = 'block';

                    // Update UI components - wichtig für die korrekte Anzeige
                    this.updateProgress();
                    this.updateQuestionOverview();
                    this.updateNavigationButtons();
                    this.updateMarkButton();
                    this.updateFilterButtons();

                    // Mehrzeiliger Log entfernt;
                },
                saveProgress: function () {
                    if (!this.isExamMode) {
                        setCookie(COOKIE_NAMES.USER_ANSWERS, this.userAnswers);
                        // Cookie-Funktionalität für markierte Fragen wurde deaktiviert
                        setCookie(COOKIE_NAMES.WRONG_QUESTIONS, Array.from(this.wrongQuestions));
                        setCookie(COOKIE_NAMES.CURRENT_QUESTION, this.currentQuestion);
                        setCookie(COOKIE_NAMES.MODE, this.isExamMode);
                        setCookie(COOKIE_NAMES.QUIZ_COMPLETED, this.quizCompleted);

                        // Cookie-Funktionalität für markierte Fragen wurde deaktiviert
                        // setCookie-Aufrufe für markierte Fragen entfernt
                    }
                },

                // Diese Funktion speichert den Status der falschen und markierten Fragen nach Abschluss des Quiz
                saveQuizState: function (completed = false) {
                    if (!this.isExamMode) {
                        this.quizCompleted = completed;
                        setCookie(COOKIE_NAMES.QUIZ_COMPLETED, completed);

                        // Wenn wir im gefilterten Falsche-Fragen-Modus sind, müssen wir die falsch beantworteten Fragen
                        // zu den bestehenden wrongQuestions hinzufügen
                        if (this.isFilteredWrongQuestions && this.questionIndices && completed) {
                            // Log entfernt

                            // Alle Fragen durchgehen und die Falsch beantworteten identifizieren
                            for (let i = 0; i < this.questions.length; i++) {
                                const userAnswer = this.userAnswers[i];
                                const correctAnswer = this.questions[i].correct;
                                const originalIndex = this.questionIndices[i]; // Original-Index der Frage

                                // Nur speichern, wenn eine Antwort gegeben wurde
                                if (userAnswer !== null) {
                                    if (userAnswer !== correctAnswer) {
                                        // Falsche Antwort - zum Set der originalWrongQuestions hinzufügen
                                        if (!this.originalWrongQuestions) {
                                            this.originalWrongQuestions = new Set();
                                        }
                                        this.originalWrongQuestions.add(originalIndex);
                                        // Log entfernt
                                    } else {
                                        // Richtige Antwort - aus dem Set entfernen
                                        if (this.originalWrongQuestions) {
                                            this.originalWrongQuestions.delete(originalIndex);
                                            // Log entfernt
                                        }
                                    }
                                }
                            }
                        }

                        // Save wrong questions
                        setCookie(COOKIE_NAMES.WRONG_QUESTIONS, Array.from(this.wrongQuestions));
                        setCookie(COOKIE_NAMES.MARKED_QUESTIONS, Array.from(this.markedQuestions));

                        // Speichere auch die originalMarkedQuestions, falls vorhanden
                        if (this.originalMarkedQuestions && this.originalMarkedQuestions.size > 0) {
                            setCookie(COOKIE_NAMES.ORIGINAL_MARKED_QUESTIONS, Array.from(this.originalMarkedQuestions));
                        }

                        // Speichere auch die originalWrongQuestions, falls vorhanden
                        if (this.originalWrongQuestions && this.originalWrongQuestions.size > 0) {
                            // Log entfernt
                            setCookie(COOKIE_NAMES.ORIGINAL_WRONG_QUESTIONS, Array.from(this.originalWrongQuestions));
                        }
                    }
                },
                loadProgress: function () {
                    // Log entfernt

                    const savedAnswers = getCookie(COOKIE_NAMES.USER_ANSWERS);
                    // Cookie-Funktionalität für markierte Fragen wurde deaktiviert
                    const savedMarked = []; // Leeres Array anstelle von Cookie-Daten
                    const savedWrong = getCookie(COOKIE_NAMES.WRONG_QUESTIONS);
                    const savedQuestion = getCookie(COOKIE_NAMES.CURRENT_QUESTION);
                    const savedMode = getCookie(COOKIE_NAMES.MODE);
                    const savedQuizCompleted = getCookie(COOKIE_NAMES.QUIZ_COMPLETED);
                    // Cookie-Funktionalität für markierte Fragen wurde deaktiviert
                    const savedOriginalMarked = []; // Leeres Array anstelle von Cookie-Daten
                    const savedOriginalWrong = getCookie(COOKIE_NAMES.ORIGINAL_WRONG_QUESTIONS);

                    // Log entfernt;

                    // Stelle sicher, dass die Sets immer initialisiert sind
                    this.wrongQuestions = new Set();
                    this.originalWrongQuestions = new Set();
                    this.markedQuestions = new Set();
                    this.originalMarkedQuestions = new Set();

                    if (savedAnswers) {
                        this.userAnswers = savedAnswers;
                        if (savedMarked) this.markedQuestions = new Set(savedMarked);
                        if (savedWrong) this.wrongQuestions = new Set(savedWrong);
                        this.currentQuestion = parseInt(savedQuestion) || 0;
                        this.isExamMode = savedMode === true;
                        this.quizCompleted = savedQuizCompleted === true;

                        // Load original marked questions if available
                        if (savedOriginalMarked) {
                            this.originalMarkedQuestions = new Set(savedOriginalMarked);
                        }

                        // Load original wrong questions if available
                        if (savedOriginalWrong) {
                            this.originalWrongQuestions = new Set(savedOriginalWrong);
                            // Log entfernt
                        }

                        // Calculate score - using both ID-based and index-based methods
                        this.score = this.userAnswers.reduce((total, answer, index) => {
                            const question = this.questions[index];
                            let isCorrect = false;

                            if (question.correctOptionId && answer !== null) {
                                // ID-based method: Check if selected option ID matches correctOptionId
                                const selectedOption = question.options[answer];
                                isCorrect = selectedOption && selectedOption.id === question.correctOptionId;
                            } else {
                                // Fallback to index-based method
                                isCorrect = answer === question.correct;
                            }

                            return total + (isCorrect ? 1 : 0);
                        }, 0);

                        return true;
                    }
                    return false;
                },

                // Code by Training 4Pilots

                stopExamTimer: function () {

                },

                // Code by Training 4Pilots
                startQuestionTimer: function () {
                    // Debugging: Ausgabe des aktuellen Zustands
                    // Log entfernt;

                    // Timer nur im Prüfungsmodus starten und nur wenn er nicht explizit gestoppt wurde
                    if (!this.isExamMode || this.timerStopped) {
                        // Im Trainingsmodus oder wenn Timer gestoppt wurde, keinen Timer anzeigen
                        const timerElement = document.querySelector('.exam-timer');
                        if (timerElement) {
                            timerElement.style.display = 'none';
                        }
                        // Log entfernt;
                        return;
                    }

                    // Timer löschen, falls er bereits läuft
                    if (this.questionTimerInterval) {
                        clearInterval(this.questionTimerInterval);
                    }

                    // Timer-Element auswählen
                    const timerElement = document.querySelector('.exam-timer');

                    // Timer-Element anzeigen
                    if (timerElement) {
                        timerElement.style.display = 'block';
                    }


                    if (this.savedQuestionTime !== undefined) {
                        // Verwende die gespeicherte Zeit
                        this.questionTimeLeft = this.savedQuestionTime;
                        // Log entfernt

                        // Gespeicherte Zeit zurücksetzen, damit sie bei der nächsten Frage nicht wiederverwendet wird
                        this.savedQuestionTime = undefined;
                    } else {
                        // Timer auf 60 Minuten (3600 Sekunden) setzen, wenn keine gespeicherte Zeit vorhanden ist
                        this.questionTimeLeft = 3600;
                        // Log entfernt
                    }

                    // Timer-Anzeige aktualisieren - Zeit in Minuten und Sekunden formatieren
                    const minutes = Math.floor(this.questionTimeLeft / 60);
                    const seconds = this.questionTimeLeft % 60;
                    document.querySelector('.time-display').textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;

                    // Setze die richtige Farbe für den Timer basierend auf der verbleibenden Zeit
                    // Bei 15 Minuten (900 Sekunden) gelb, bei 5 Minuten (300 Sekunden) rot
                    if (this.questionTimeLeft <= 900 && this.questionTimeLeft > 300) {
                        timerElement.style.backgroundColor = '#ffc107'; // Gelb
                        timerElement.style.color = 'white'; // Weiße Schrift auf gelbem Hintergrund
                    } else if (this.questionTimeLeft <= 300) {
                        timerElement.style.backgroundColor = '#dc3545'; // Rot
                        timerElement.style.color = 'white'; // Weiße Schrift auf rotem Hintergrund
                    } else {
                        timerElement.style.backgroundColor = 'white'; // Weißer Hintergrund (Standard)
                        timerElement.style.color = '#1d232b'; // Dunkle Schrift
                    }

                    // Timer starten, der jede Sekunde aktualisiert wird
                    this.questionTimerInterval = setInterval(() => {
                        this.questionTimeLeft--;

                        // Speichere die verbleibende Zeit, damit sie verfügbar ist, wenn der Timer pausiert wird
                        this.remainingQuestionTime = this.questionTimeLeft;

                        // Timer-Anzeige aktualisieren - Zeit in Minuten und Sekunden formatieren
                        const minutes = Math.floor(this.questionTimeLeft / 60);
                        const seconds = this.questionTimeLeft % 60;
                        document.querySelector('.time-display').textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;

                        // Hintergrundfarbe des Timers auf Gelb ändern, wenn 15 Minuten (900 Sekunden) übrig sind
                        if (this.questionTimeLeft === 900) {
                            timerElement.style.backgroundColor = '#ffc107'; // Gelb
                            timerElement.style.color = 'white'; // Weiße Schrift auf gelbem Hintergrund
                        }

                        // Hintergrundfarbe des Timers auf Rot ändern, wenn 5 Minuten (300 Sekunden) übrig sind
                        if (this.questionTimeLeft === 300) {
                            timerElement.style.backgroundColor = '#dc3545'; // Rot
                            timerElement.style.color = 'white'; // Weiße Schrift auf rotem Hintergrund
                        }

                        // Wenn Timer abgelaufen ist, Modal anzeigen, aber nur wenn Timer nicht explizit gestoppt wurde
                        if (this.questionTimeLeft <= 0) {
                            clearInterval(this.questionTimerInterval);
                            this.questionTimerInterval = null;

                            // Modal mit "Zeit abgelaufen" nur anzeigen, wenn:
                            // 1. Timer nicht explizit gestoppt wurde
                            // 2. Wir uns noch im Prüfungsmodus befinden (nicht in der Modusauswahl)
                            // 3. Der Quiz-Inhalt sichtbar ist (nicht die Modusauswahl)
                            const quizContentVisible = document.querySelector('.quiz-content').style.display !== 'none';
                            const modeSelectionVisible = document.querySelector('.mode-selection').style.display === 'block';

                            // Log entfernt;

                            if (!this.timerStopped && this.isExamMode && quizContentVisible && !modeSelectionVisible) {
                                // Log entfernt
                                this.showTimeUpModal();
                            } else {
                                // Log entfernt
                            }
                        }
                    }, 1000);
                },

                loadQuestion: function () {
                    // Log entfernt

                    // Prüfe, ob questions definiert ist und einen gültigen Index hat
                    if (!this.questions || this.questions.length === 0 || this.currentQuestion < 0 || this.currentQuestion >= this.questions.length) {
                        console.warn("Keine Fragen vorhanden oder ungültiger Fragenindex");
                        return;
                    }

                    // Wenn wir im Modus für falsche Fragen sind, stellen wir sicher, dass die Navigation korrekt ist
                    if (this.isFilteredWrongQuestions) {
                        // Wir rufen später fixNavigationHighlighting auf, um sicherzustellen, dass nur
                        // die aktuelle Frage hervorgehoben wird
                    }

                    const question = this.questions[this.currentQuestion];

                    // Prüfe, ob die Frage korrekt ist
                    if (!question || !question.question) {
                        console.warn("Frage hat kein gültiges Format");
                        return;
                    }

                    const questionText = document.querySelector('.question-text');
                    if (!questionText) {
                        console.warn("Question-Text-Element nicht gefunden");
                        return;
                    }

                    questionText.textContent = question.question;
                    questionText.style.display = 'block';

                    // Frage-Zähler Code entfernt

                    // KRITISCH: Stelle sicher, dass alle Sets initialisiert sind
                    if (!this.markedQuestions) this.markedQuestions = new Set();
                    if (!this.examMarkedQuestions) this.examMarkedQuestions = new Set();
                    if (!this.originalMarkedQuestions) this.originalMarkedQuestions = new Set();

                    // Ausgabe der markierten Fragen für besseres Debugging

                    // Aktualisiere den Markierungs-Button, damit er jederzeit den korrekten Status zeigt
                    this.updateMarkButton();

                    const optionsContainer = document.querySelector('.options-container');
                    optionsContainer.innerHTML = '';

                    // Speichere die ursprünglichen Indizes und gemischten Indizes für spätere Verweise
                    if (!this.currentShuffledIndices) {
                        this.currentShuffledIndices = {};
                    }

                    // Prüfe, ob wir bereits eine Reihenfolge für diese Frage haben
                    // Falls nicht, erstellen wir eine neue und speichern sie
                    if (!this.currentShuffledIndices[this.currentQuestion]) {
                        const shuffledIndices = [...Array(question.options.length).keys()];
                        shuffledIndices.sort(() => 0.5 - Math.random());

                        // Speichere die gemischten Indizes für die aktuelle Frage
                        this.currentShuffledIndices[this.currentQuestion] = shuffledIndices;
                    }

                    // Verwende die gespeicherte Reihenfolge
                    const shuffledIndices = this.currentShuffledIndices[this.currentQuestion];

                    // Ordne den gemischten Indizes ihre Position in der UI zu
                    const shuffledPositions = {};
                    shuffledIndices.forEach((originalIndex, newPosition) => {
                        shuffledPositions[originalIndex] = newPosition;
                    });

                    shuffledIndices.forEach((originalIndex, displayIndex) => {
                        const option = question.options[originalIndex];
                        const button = document.createElement('button');
                        button.className = 'option-button';

                        // Überprüfen, ob die Option ein Objekt oder ein String ist (neue vs alte Struktur)
                        if (typeof option === 'object' && option !== null && option.text) {
                            // Neue Struktur mit IDs: Verwende das text-Feld
                            button.textContent = option.text;
                            // Speichere die ID als data-Attribut für spätere Verwendung
                            button.dataset.optionId = option.id;
                        } else {
                            // Alte Struktur: Direkt den String verwenden
                            button.textContent = option;
                        }

                        if (!this.isExamMode) {
                            button.onclick = () => this.selectAnswer(originalIndex);
                            // Überprüfen, ob wir im falschen Fragen oder markierten Fragen Modus sind
                            // Wenn ja, keine Antworten als ausgewählt anzeigen
                            if (this.userAnswers[this.currentQuestion] !== null && !this.isFilteredWrongQuestions && !this.isFilteredMarkedQuestions) {
                                // Ermittle, ob diese Option die korrekte ist, verwende ID-basierte Methode wenn verfügbar
                                let isCorrectOption = false;
                                if (question.correctOptionId) {
                                    const option = question.options[originalIndex];
                                    isCorrectOption = option && option.id === question.correctOptionId;
                                } else {
                                    isCorrectOption = originalIndex === question.correct;
                                }

                                if (isCorrectOption) {
                                    button.classList.add('correct');
                                } else if (originalIndex === this.userAnswers[this.currentQuestion]) {
                                    button.classList.add('incorrect');
                                }
                                button.disabled = true;
                            } else if (this.isFilteredWrongQuestions || this.isFilteredMarkedQuestions) {
                                // Im Modus für falsche oder markierte Fragen
                                // Prüfen, ob diese Frage bereits beantwortet wurde
                                if (this.userAnswers[this.currentQuestion] !== null) {
                                    // Zeige die gewählte Antwort und die richtige Antwort an
                                    // Ermittle, ob diese Option die korrekte ist, verwende ID-basierte Methode wenn verfügbar
                                    let isCorrectOption = false;
                                    if (question.correctOptionId) {
                                        const option = question.options[originalIndex];
                                        isCorrectOption = option && option.id === question.correctOptionId;
                                    } else {
                                        isCorrectOption = originalIndex === question.correct;
                                    }

                                    if (isCorrectOption) {
                                        button.classList.add('correct');
                                    } else if (originalIndex === this.userAnswers[this.currentQuestion]) {
                                        button.classList.add('incorrect');
                                    }
                                    button.disabled = true;
                                } else {
                                    // Wenn die Frage noch nicht beantwortet wurde, Button aktiv lassen
                                    button.classList.remove('correct', 'incorrect');
                                    button.disabled = false;
                                }
                            }
                        } else {
                            button.onclick = () => this.selectAnswer(originalIndex);
                            if (this.userAnswers[this.currentQuestion] === originalIndex) {
                                button.classList.add('selected-exam');
                            }
                        }

                        optionsContainer.appendChild(button);
                    });

                    this.updateNavigationButtons();
                    this.updateMarkButton();

                    // Timer nur bei der ersten Frage starten und nur wenn es nicht bereits läuft
                    if (this.currentQuestion === 0 && !this.questionTimerInterval && this.isExamMode) {
                        this.startQuestionTimer();
                    }
                },
                selectAnswer: function (index) {
                    // Log entfernt

                    const question = this.questions[this.currentQuestion];
                    const buttons = document.querySelectorAll('.option-button');

                    if (!this.isExamMode) {
                        buttons.forEach(button => {
                            button.classList.remove('correct', 'incorrect');
                            button.disabled = true;
                        });

                        // EXTREM VEREINFACHTE LÖSUNG:
                        // Statt komplizierter Logik mit verschiedenen Sets und Indizes
                        // führen wir ein einfaches Array ein, das direkt die Fragen-Indizes speichert

                        // Erstelle das Array, falls es noch nicht existiert
                        if (!window.falscheFragenIndizes) {
                            window.falscheFragenIndizes = [];
                        }

                        // Für den aktuellen Test ein separates Array, um nur die Fragen dieses Tests zu speichern
                        if (!window.aktuelleTestFalscheIndizes) {
                            window.aktuelleTestFalscheIndizes = [];
                        }

                        // Bestimme den Index und die ID der aktuellen Frage
                        // Bei normalen Fragen ist das einfach currentQuestion
                        // Bei gefilterten Fragen (isFilteredWrongQuestions) ist es der Original-Index über questionIndices
                        let globalIndex;
                        let questionId;

                        // Hole die aktuelle Frage 
                        const currentQuestion = this.questions[this.currentQuestion];

                        // ID der aktuellen Frage extrahieren (robust)
                        questionId = currentQuestion && currentQuestion.id ? currentQuestion.id : null;

                        if (this.isFilteredWrongQuestions && this.questionIndices) {
                            // Im Falsche-Fragen-Modus: originalIndex aus questionIndices
                            globalIndex = this.questionIndices[this.currentQuestion];
                        } else {
                            // Normaler Modus: einfach currentQuestion
                            globalIndex = this.currentQuestion;
                        }

                        // Finde alle Buttons, die Antwortoptionen darstellen
                        let correctButton = null;
                        let selectedButton = null;

                        buttons.forEach((button, buttonIndex) => {
                            // Ermittle den originalIndex der Button-Option basierend auf dem Textinhalt
                            const buttonText = button.textContent;
                            let originalOptionIndex = null;

                            // Finde den originalIndex, der zum Textinhalt passt
                            for (let i = 0; i < question.options.length; i++) {
                                const currentOption = question.options[i];
                                // Prüfe, ob Option ein Objekt oder String ist
                                if (typeof currentOption === 'object' && currentOption !== null && currentOption.text) {
                                    // Bei Objekten mit text-Attribut
                                    if (currentOption.text === buttonText) {
                                        originalOptionIndex = i;
                                        break;
                                    }
                                } else {
                                    // Bei einfachen String-Optionen (alte Struktur)
                                    if (currentOption === buttonText) {
                                        originalOptionIndex = i;
                                        break;
                                    }
                                }
                            }

                            // Speichere Referenzen auf den korrekten Button und den ausgewählten Button
                            // Verwende ID-basierte Methode, wenn verfügbar
                            if (question.correctOptionId && question.options[originalOptionIndex] &&
                                question.options[originalOptionIndex].id === question.correctOptionId) {
                                correctButton = button;
                            } else if (originalOptionIndex === question.correct) {
                                // Fallback auf index-basierte Methode
                                correctButton = button;
                            }

                            if (originalOptionIndex === index) {
                                selectedButton = button;
                            }
                        });

                        // Prüfe, ob die ausgewählte Antwort korrekt ist, bevorzuge ID-basierte Methode
                        const isCorrect = question.correctOptionId ?
                            (question.options[index] && question.options[index].id === question.correctOptionId) :
                            (index === question.correct);

                        if (isCorrect) {
                            // Richtige Antwort
                            selectedButton.classList.add('correct');
                            this.score++;

                            // Entferne die Frage aus beiden Arrays, falls sie vorhanden ist

                            // 1. Aus globalem Array entfernen (falscheFragenIndizes)
                            // Falls die Frage mit ID oder Index gespeichert wurde, prüfen wir beide Werte
                            const idToRemove = questionId || globalIndex;

                            const indexInArray = window.falscheFragenIndizes.indexOf(idToRemove);
                            if (indexInArray !== -1) {
                                window.falscheFragenIndizes.splice(indexInArray, 1);
                            }

                            // 2. Aus aktuellem Test-Array entfernen (aktuelleTestFalscheIndizes)
                            const indexInCurrentTest = window.aktuelleTestFalscheIndizes.indexOf(idToRemove);
                            if (indexInCurrentTest !== -1) {
                                window.aktuelleTestFalscheIndizes.splice(indexInCurrentTest, 1);
                            }

                            // Log entfernt;
                        } else {
                            // Falsche Antwort
                            selectedButton.classList.add('incorrect');
                            correctButton.classList.add('correct');

                            // Füge sowohl den Index als auch die ID zu beiden falschen Fragen-Arrays hinzu

                            // Verwende ID statt Index (wenn verfügbar)
                            const idToStore = questionId || globalIndex;

                            // 1. Zum globalen Array (falscheFragenIndizes)
                            if (window.falscheFragenIndizes.indexOf(idToStore) === -1) {
                                window.falscheFragenIndizes.push(idToStore);
                            }

                            // 2. Zum aktuellen Test-Array (aktuelleTestFalscheIndizes)
                            if (window.aktuelleTestFalscheIndizes.indexOf(idToStore) === -1) {
                                window.aktuelleTestFalscheIndizes.push(idToStore);
                            }

                            // Log entfernt;
                        }

                        // Speichere beide Arrays im lokalStorage
                        localStorage.setItem('falscheFragenIndizes', JSON.stringify(window.falscheFragenIndizes));
                        localStorage.setItem('aktuelleTestFalscheIndizes', JSON.stringify(window.aktuelleTestFalscheIndizes));

                        // Update wrongQuestions Set basierend auf aktuelle falsche Fragen
                        // Verwende die IDs direkt, ohne Umwandlung in Zahlen, da es jetzt String-IDs sein können
                        this.wrongQuestions = new Set(window.aktuelleTestFalscheIndizes);

                        // Aktualisiere den Button-Status, damit der "Falsche Fragen laden" Button
                        // deaktiviert wird, wenn alle Fragen richtig beantwortet wurden
                        this.updateFilterButtons();
                    } else {
                        // Exam-Modus
                        buttons.forEach(button => button.classList.remove('selected-exam'));

                        // Finde den Button mit dem ausgewählten Original-Index
                        buttons.forEach((button, btnIndex) => {
                            const buttonText = button.textContent;
                            // Finde den originalIndex, der zum Textinhalt passt
                            for (let i = 0; i < question.options.length; i++) {
                                if (i === index) {
                                    const currentOption = question.options[i];
                                    // Prüfe, ob die Option ein Objekt mit text-Attribut ist
                                    if (typeof currentOption === 'object' && currentOption !== null && currentOption.text) {
                                        if (currentOption.text === buttonText) {
                                            button.classList.add('selected-exam');
                                            break;
                                        }
                                    } else {
                                        // Alte Struktur: direkter String-Vergleich
                                        if (currentOption === buttonText) {
                                            button.classList.add('selected-exam');
                                            break;
                                        }
                                    }
                                }
                            }
                        });
                    }

                    this.userAnswers[this.currentQuestion] = index;

                    // Die aktuelle Frage holen
                    const currentQuestion = this.questions[this.currentQuestion];

                    // Sicherstellen, dass die Frage eine ID hat
                    if (!currentQuestion || !currentQuestion.id) {
                        console.error("Frage hat keine ID oder existiert nicht:", this.currentQuestion);
                        return;
                    }

                    // Die eindeutige Frage-ID verwenden
                    const questionId = currentQuestion.id;

                    // Wenn wir im Modus für markierte Fragen sind, markiere diese Frage als beantwortet,
                    // aber entferne sie NICHT aus originalMarkedQuestions
                    if (this.isFilteredMarkedQuestions) {
                        // In diesem Modus entfernen wir sie nur aus dem temporären Set, 
                        // aber behalten sie in originalMarkedQuestions
                        if (this.markedQuestions.has(questionId)) {
                            // Entferne sie nur aus dem temporären markedQuestions
                            this.markedQuestions.delete(questionId);
                        }
                    }
                    // Im normalen Modus prüfen wir, ob die Frage markiert ist
                    else if (this.isQuestionMarked(questionId)) {
                        this.updateMarkButton();
                    }

                    // Speichern der aktualisierten markierten Fragen
                    if (!this.isExamMode) {
                        setCookie(COOKIE_NAMES.MARKED_QUESTIONS, Array.from(this.markedQuestions));
                        // Aktualisiere auch originalMarkedQuestions im Cookie, falls vorhanden
                        if (this.originalMarkedQuestions) {
                            setCookie(COOKIE_NAMES.ORIGINAL_MARKED_QUESTIONS, Array.from(this.originalMarkedQuestions));
                        }
                    }

                    this.updateProgress();
                    this.updateQuestionOverview();

                    // Fix für das Problem mit mehrfacher Markierung in der Navigation
                    // Dies ist besonders wichtig bei falschen Fragen aus verschiedenen Blöcken
                    if (this.isFilteredWrongQuestions) {
                        this.fixNavigationHighlighting();
                    }
                },
                updateProgress: function () {
                    if (!this.isExamMode) {
                        const totalQuestions = this.questions.length;
                        const answeredQuestions = this.userAnswers.filter(answer => answer !== null).length;
                        const correctAnswers = this.userAnswers.reduce((total, answer, index) => {
                            const question = this.questions[index];
                            let isCorrect = false;

                            if (question.correctOptionId && answer !== null) {
                                // ID-basierte Methode: Prüfe, ob die ID der gewählten Option mit correctOptionId übereinstimmt
                                const selectedOption = question.options[answer];
                                isCorrect = selectedOption && selectedOption.id === question.correctOptionId;
                            } else {
                                // Fallback auf index-basierte Methode
                                isCorrect = answer === question.correct;
                            }

                            return total + (isCorrect ? 1 : 0);
                        }, 0);

                        const correctPercentage = (correctAnswers / totalQuestions) * 100;
                        const answeredPercentage = (answeredQuestions / totalQuestions) * 100;

                        const progressBar = document.querySelector('.progress-bar');
                        progressBar.style.setProperty('--correct-percentage', `${correctPercentage}%`);
                        progressBar.style.setProperty('--answered-percentage', `${answeredPercentage}%`);
                    }
                },
                updateNavigationButtons: function () {
                    // Prüfe, ob wir bei der ersten oder letzten Frage sind
                    const isFirstQuestion = this.currentQuestion === 0;
                    const isLastQuestion = this.currentQuestion === this.questions.length - 1;

                    // Untere Navigations-Buttons aktualisieren
                    const backButton = document.querySelector('.back-button');
                    const nextButton = document.querySelector('.next-button');

                    if (backButton) {
                        // Setze disabled-Attribut
                        backButton.disabled = isFirstQuestion;

                        // Visuelles Feedback durch Ausgrauen
                        if (isFirstQuestion) {
                            backButton.classList.add('disabled');
                            backButton.style.opacity = "0.5";
                            backButton.style.cursor = "not-allowed";
                        } else {
                            backButton.classList.remove('disabled');
                            backButton.style.opacity = "1";
                            backButton.style.cursor = "pointer";
                        }
                    }

                    if (nextButton) {
                        // Setze disabled-Attribut
                        nextButton.disabled = isLastQuestion;

                        // Visuelles Feedback durch Ausgrauen
                        if (isLastQuestion) {
                            nextButton.classList.add('disabled');
                            nextButton.style.opacity = "0.5";
                            nextButton.style.cursor = "not-allowed";
                        } else {
                            nextButton.classList.remove('disabled');
                            nextButton.style.opacity = "1";
                            nextButton.style.cursor = "pointer";
                        }
                    }

                    // Obere Navigations-Pfeile (in der Fragenübersicht) aktualisieren
                    const overviewPrev = document.getElementById('overview-prev');
                    const overviewNext = document.getElementById('overview-next');

                    if (overviewPrev) {
                        // Setze disabled-Attribut
                        overviewPrev.disabled = isFirstQuestion;

                        // Visuelles Feedback durch Ausgrauen
                        if (isFirstQuestion) {
                            overviewPrev.classList.add('disabled');
                            overviewPrev.style.opacity = "0.5";
                            overviewPrev.style.cursor = "not-allowed";
                        } else {
                            overviewPrev.classList.remove('disabled');
                            overviewPrev.style.opacity = "1";
                            overviewPrev.style.cursor = "pointer";
                        }
                    }

                    if (overviewNext) {
                        // Setze disabled-Attribut
                        overviewNext.disabled = isLastQuestion;

                        // Visuelles Feedback durch Ausgrauen
                        if (isLastQuestion) {
                            overviewNext.classList.add('disabled');
                            overviewNext.style.opacity = "0.5";
                            overviewNext.style.cursor = "not-allowed";
                        } else {
                            overviewNext.classList.remove('disabled');
                            overviewNext.style.opacity = "1";
                            overviewNext.style.cursor = "pointer";
                        }
                    }
                },
                updateMarkButton: function () {
                    console.log("updateMarkButton wird aufgerufen");

                    // Aktualisieren der Markierungsanzeige für den aktuellen Zustand des Markierungs-Buttons
                    const markButton = document.querySelector('.mark-button');
                    if (!markButton) {
                        console.warn("Mark-Button nicht gefunden");
                        return; // Wenn kein Button vorhanden ist, nichts tun
                    }

                    // WICHTIG: Stelle sicher, dass alle Sets initialisiert sind
                    if (!this.markedQuestions) this.markedQuestions = new Set();
                    if (!this.examMarkedQuestions) this.examMarkedQuestions = new Set();
                    if (!this.originalMarkedQuestions) this.originalMarkedQuestions = new Set();

                    // Standardmäßig ist die Frage nicht markiert
                    let isMarked = false;

                    // Prüfe, ob überhaupt Fragen geladen sind
                    if (!this.questions || this.questions.length === 0) {
                        console.warn("Keine Fragen geladen - Button wird deaktiviert");
                        markButton.disabled = true;
                        return;
                    }

                    // Prüfe, ob der currentQuestion-Index gültig ist
                    if (this.currentQuestion === undefined || this.currentQuestion < 0 || this.currentQuestion >= this.questions.length) {
                        console.warn(`Ungültiger Fragenindex: ${this.currentQuestion}`);
                        markButton.disabled = true;
                        return;
                    }

                    // Die aktuelle Frage holen, um die ID zu bekommen
                    const currentQuestion = this.questions[this.currentQuestion];

                    // Prüfe, ob die Frage existiert
                    if (!currentQuestion) {
                        console.warn(`Frage mit Index ${this.currentQuestion} existiert nicht`);
                        markButton.disabled = true;
                        return;
                    }

                    // Prüfe, ob die Frage eine ID hat
                    if (!currentQuestion.id) {
                        console.warn("Aktuelle Frage hat keine gültige ID");
                        markButton.disabled = true;
                        return;
                    }

                    // Button aktivieren, da die Frage gültig ist
                    markButton.disabled = false;

                    const questionId = currentQuestion.id;
                    console.log(`Prüfe Markierungsstatus für Frage ID: ${questionId}`);

                    // Prüfen, ob die Frage in einem der Sets markiert ist
                    const isMarkedInMain = this.markedQuestions.has(questionId);
                    const isMarkedInExam = this.examMarkedQuestions.has(questionId);
                    const isMarkedInOriginal = this.originalMarkedQuestions.has(questionId);

                    // Eine Frage gilt als markiert, wenn sie in irgendeinem Set ist
                    isMarked = isMarkedInMain || isMarkedInExam || isMarkedInOriginal;

                    // CSS-Klassen aktualisieren
                    markButton.classList.toggle('marked', isMarked);
                    markButton.classList.toggle('active', isMarked);
                    markButton.title = isMarked ? 'Markierung entfernen' : 'Frage markieren';

                    // Lesezeichen-Symbol mit angepassten Farben
                    markButton.innerHTML = '<i class="fas fa-bookmark"></i>';
                    markButton.style.color = isMarked ? '#1d232b' : '#ffffff';

                    // Button immer aktiv halten
                    markButton.disabled = false;
                },
                showResults: function () {
                    // Markierungen zurücksetzen, wenn Ergebnisse angezeigt werden
                    this.markedQuestions.clear();
                    this.examMarkedQuestions.clear();
                    this.originalMarkedQuestions.clear();

                    // Im Prüfungsmodus: Stelle sicher, dass die body-Klasse korrekt gesetzt ist
                    if (this.isExamMode) {
                        document.body.classList.add('exam-mode');

                        // Verstecke die Filter-Buttons direkt, wenn wir im Prüfungsmodus sind
                        const filterButtons = document.querySelector('.filter-buttons');
                        if (filterButtons) {
                            filterButtons.style.display = 'none';
                            // Log entfernt
                        }

                        // Timer stoppen, falls er läuft
                        if (this.examTimerInterval) {
                            this.stopExamTimer();
                        }
                    } else {
                        // Im Trainingsmodus: Stelle sicher, dass die Klasse entfernt ist
                        document.body.classList.remove('exam-mode');
                    }

                    // Stoppe den Quiz-Timer
                    if (this.questionTimerInterval) {
                        clearInterval(this.questionTimerInterval);
                        // Timer-Element verbergen
                        const timerElement = document.querySelector('.exam-timer');
                        if (timerElement) {
                            timerElement.style.display = 'none';
                        }
                    }

                    this.quizCompleted = true;

                    // Sichern der markierten Fragen vor Anzeige der Ergebnisse
                    // Log entfernt

                    // Stelle sicher, dass originalMarkedQuestions initialisiert ist
                    if (!this.originalMarkedQuestions) {
                        this.originalMarkedQuestions = new Set();
                    }

                    // Wichtig: Kopiere alle aktuellen markierten Fragen in originalMarkedQuestions
                    // Dies verhindert, dass markierte Fragen verloren gehen, wenn Ergebnisse angezeigt werden
                    if (this.markedQuestions && this.markedQuestions.size > 0) {
                        this.markedQuestions.forEach(questionId => {
                            // Jetzt verwenden wir direkt die QuestionId, keine Umwandlung nötig
                            this.originalMarkedQuestions.add(questionId);
                        });

                        // Speichere originalMarkedQuestions in Cookies für Persistenz
                        setCookie(COOKIE_NAMES.ORIGINAL_MARKED_QUESTIONS, Array.from(this.originalMarkedQuestions));
                        // Log entfernt
                    }

                    // Beim Anzeigen der Ergebnisse speichern wir die aktuelleTestFalscheIndizes
                    // im localStorage, damit die falschen Fragen des aktuellen Tests verfügbar sind
                    localStorage.setItem('aktuelleTestFalscheIndizes', JSON.stringify(window.aktuelleTestFalscheIndizes || []));

                    // Speichere die aktuellen falschen Fragen in originalWrongQuestions
                    // Dies stellt sicher, dass wir nur die falschen Fragen des aktuellen Tests haben
                    this.originalWrongQuestions = new Set(this.wrongQuestions);

                    // Speichere originalWrongQuestions in Cookies für Persistenz
                    setCookie(COOKIE_NAMES.ORIGINAL_WRONG_QUESTIONS, Array.from(this.originalWrongQuestions));
                    // Log entfernt

                    // Zusätzliche Verarbeitung für markierte Fragen im gefilterten Modus
                    // Im gefilterten Modus verwenden wir jetzt direkt IDs statt Indizes
                    if (this.isFilteredMarkedQuestions) {
                        // Die markierten Fragen werden jetzt bereits als IDs gespeichert, also ist keine
                        // spezielle Konvertierung mehr nötig. Wir können direkt aus markedQuestions kopieren.
                        const markedArray = Array.from(this.markedQuestions);
                        markedArray.forEach(questionId => {
                            // Direkt die ID in originalMarkedQuestions speichern
                            this.originalMarkedQuestions.add(questionId);
                        });

                        // Nach der Verarbeitung speichern
                        setCookie(COOKIE_NAMES.ORIGINAL_MARKED_QUESTIONS, Array.from(this.originalMarkedQuestions));

                        // Debug-Ausgabe für die Nachverfolgung
                        console.log("Markierte Fragen-IDs nach Speicherung:", Array.from(this.originalMarkedQuestions));
                    }

                    // Überprüfe, ob überhaupt Fragen beantwortet wurden
                    const anyQuestionsAnswered = this.userAnswers.some(answer => answer !== null);

                    // Wenn keine Fragen beantwortet wurden, leere die falschen Fragen-Sets
                    // Dies stellt sicher, dass der "Falsche Fragen laden"-Button deaktiviert bleibt
                    if (!anyQuestionsAnswered) {
                        // Log entfernt
                        this.wrongQuestions.clear();
                        this.originalWrongQuestions.clear();
                        // Auch die globalen Arrays leeren
                        if (window.aktuelleTestFalscheIndizes) {
                            window.aktuelleTestFalscheIndizes = [];
                        }
                        if (window.falscheFragenIndizes) {
                            window.falscheFragenIndizes = [];
                        }
                        // localStorage-Einträge entfernen
                        localStorage.removeItem('aktuelleTestFalscheIndizes');
                        localStorage.removeItem('falscheFragenIndizes');
                    }

                    // Speichere den Quiz-Status und die falschen Fragen
                    this.saveQuizState(true);

                    // Verstecke den question-container und zeige den results-container
                    document.querySelector('.question-container').style.display = 'none';
                    document.querySelector('.results-container').style.display = 'flex';
                    document.querySelector('.results-container').style.justifyContent = 'center';
                    document.querySelector('.results-container').style.alignItems = 'center';

                    // Verstecke die Navigationsleiste auf der Statistikseite
                    document.querySelector('.question-overview').style.display = 'none';

                    // Im Prüfungsmodus: Filter-Buttons vollständig ausblenden
                    if (this.isExamMode) {
                        const filterButtons = document.querySelector('.filter-buttons');
                        if (filterButtons) {
                            filterButtons.style.display = 'none';
                            // Log entfernt
                        }

                        // Wichtig: Verzögerung hinzufügen, um sicherzustellen, dass die Buttons ausgeblendet bleiben
                        setTimeout(() => {
                            const btns = document.querySelector('.filter-buttons');
                            if (btns) {
                                btns.style.display = 'none';
                                // Log entfernt
                            }
                        }, 100);
                    } else {
                        // Nur im Trainingsmodus: Aktiviere/Deaktiviere die Filter-Buttons
                        this.updateFilterButtons();
                    }

                    // Füge einen Ergebnis-Text über den Ergebnissen hinzu
                    const existingHeading = document.querySelector('.results-container .test-completed-heading');

                    // Berechne Prozentsatz der richtigen Antworten für die Statusanzeige mit ID-basierter Methode
                    const totalQuestions = this.questions.length;
                    const correctAnswers = this.userAnswers.reduce((count, answer, index) => {
                        const question = this.questions[index];
                        let isCorrect = false;

                        if (question.correctOptionId && answer !== null) {
                            // ID-basierte Methode: Prüfe, ob die ID der gewählten Option mit correctOptionId übereinstimmt
                            const selectedOption = question.options[answer];
                            isCorrect = selectedOption && selectedOption.id === question.correctOptionId;
                        } else {
                            // Fallback auf index-basierte Methode
                            isCorrect = answer === question.correct;
                        }

                        return count + (isCorrect ? 1 : 0);
                    }, 0);

                    const percentage = Math.round((correctAnswers / totalQuestions) * 100);

                    // Erstelle oder aktualisiere die Überschrift
                    let headingText, headingColor;

                    // Im Prüfungsmodus: Zeige "Prüfung bestanden!" oder "Prüfung nicht bestanden!" je nach Prozentsatz
                    if (this.isExamMode) {
                        if (percentage >= 75) {
                            headingText = "Prüfung bestanden!";
                            headingColor = "#198754"; // Grün
                        } else {
                            headingText = "Prüfung nicht bestanden!";
                            headingColor = "#dc3545"; // Rot
                        }
                    } else {
                        // Im Trainingsmodus bleibt die Anzeige neutral
                        headingText = "Test abgeschlossen";
                        headingColor = "#1d232b"; // Dunkelgrau
                    }

                    if (!existingHeading) {
                        const resultsHeading = document.createElement('div');
                        resultsHeading.className = 'test-completed-heading';
                        resultsHeading.innerHTML = `<div style="color: ${headingColor}; font-weight: 600; text-align: center; width: 100%; font-size: 1.5rem; margin-bottom: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;">${headingText}</div>`;
                        document.querySelector('.results-container').prepend(resultsHeading);
                    } else {
                        // Aktualisiere den existierenden Heading
                        existingHeading.innerHTML = `<div style="color: ${headingColor}; font-weight: 600; text-align: center; width: 100%; font-size: 1.5rem; margin-bottom: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;">${headingText}</div>`;
                    }

                    // Berechne die restlichen Statistiken mit ID-basierter Methode
                    // Diese Berechnung nochmals explizit durchführen, um sicherzustellen, dass die Werte korrekt sind

                    // 1. Korrekte Antworten zählen
                    let correctAnswersCount = 0;
                    let incorrectAnswersCount = 0;
                    let unansweredCount = 0;

                    // Durchgehe alle Fragen und zähle die korrekten/falschen/unbeantworteten
                    for (let i = 0; i < this.questions.length; i++) {
                        const answer = this.userAnswers[i];
                        const question = this.questions[i];

                        if (answer === null) {
                            // Nicht beantwortet
                            unansweredCount++;
                        } else {
                            // Beantwortet - prüfe ob korrekt
                            let isCorrect = false;

                            if (question.correctOptionId) {
                                // ID-basierte Methode: Prüfe, ob die ID der gewählten Option mit correctOptionId übereinstimmt
                                const selectedOption = question.options[answer];
                                isCorrect = selectedOption && selectedOption.id === question.correctOptionId;
                            } else {
                                // Fallback auf index-basierte Methode
                                isCorrect = answer === question.correct;
                            }

                            if (isCorrect) {
                                correctAnswersCount++;
                            } else {
                                incorrectAnswersCount++;
                            }
                        }
                    }

                    // Verwende die neu berechneten Werte
                    let finalCorrectAnswers = correctAnswersCount;
                    let finalIncorrectAnswers = incorrectAnswersCount;
                    let finalUnanswered = unansweredCount;

                    // Korrekten Prozentsatz neu berechnen
                    let finalPercentage = Math.round((finalCorrectAnswers / totalQuestions) * 100);

                    // Double-check: Die Summe sollte gleich der Gesamtzahl sein
                    if (finalCorrectAnswers + finalIncorrectAnswers + finalUnanswered !== totalQuestions) {
                        console.warn("Statistik-Fehler: Die Summe der Antworten stimmt nicht mit der Gesamtzahl überein",
                            { correct: finalCorrectAnswers, incorrect: finalIncorrectAnswers, unanswered: finalUnanswered, total: totalQuestions });
                    }

                    // Erstelle das Kuchendiagramm
                    const ctx = document.getElementById('resultsChart').getContext('2d');
                    if (window.resultChart) {
                        window.resultChart.destroy();
                    }
                    window.resultChart = new Chart(ctx, {
                        type: 'pie',
                        data: {
                            labels: ['Richtig', 'Falsch', 'Unbeantwortet'],
                            datasets: [{
                                data: [finalCorrectAnswers, finalIncorrectAnswers, finalUnanswered],
                                backgroundColor: ['#198754', '#dc3545', '#1d232b'],
                                borderWidth: 1,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        padding: 20,
                                        font: {
                                            size: 14
                                        }
                                    }
                                }
                            }
                        }
                    });

                    // Zeige die Ergebnisse
                    const resultsText = document.querySelector('.results-text');

                    // Baue die HTML-Ausgabe dynamisch auf, abhängig davon, ob es Ergebnisse gibt
                    let resultsHTML = '';

                    // Füge die Box für richtige Antworten nur hinzu, wenn es mindestens eine gibt
                    if (finalCorrectAnswers > 0) {
                        resultsHTML += `<span class="text-success">Du hast ${finalCorrectAnswers} von ${totalQuestions} Fragen richtig beantwortet (${finalPercentage}%).</span>`;
                    }

                    // Füge die Box für falsche Antworten nur hinzu, wenn es mindestens eine gibt
                    if (finalIncorrectAnswers > 0) {
                        resultsHTML += `<span class="text-danger">${finalIncorrectAnswers} Fragen wurden falsch beantwortet (${Math.round((finalIncorrectAnswers / totalQuestions) * 100)}%).</span>`;
                    }

                    // Füge die Box für unbeantwortete Fragen nur hinzu, wenn es mindestens eine gibt
                    if (finalUnanswered > 0) {
                        resultsHTML += `<span class="text-unanswered">${finalUnanswered} Fragen wurden nicht beantwortet (${Math.round((finalUnanswered / totalQuestions) * 100)}%).</span>`;
                    }

                    // Setze das HTML
                    resultsText.innerHTML = resultsHTML;

                    // Zeige falsche Antworten
                    const wrongAnswersContainer = document.querySelector('.wrong-answers');
                    wrongAnswersContainer.innerHTML = '';

                    if (finalIncorrectAnswers > 0) {
                        const wrongAnswersList = document.createElement('div');
                        wrongAnswersList.className = 'wrong-answers-list';
                        wrongAnswersList.innerHTML = '<h3>Falsch beantwortete Fragen:</h3>';

                        this.userAnswers.forEach((answer, index) => {
                            // Überprüfe, ob die Antwort falsch ist - bevorzuge ID-basierte Methode
                            const question = this.questions[index];
                            let isCorrect = false;

                            if (question.correctOptionId && answer !== null) {
                                // ID-basierte Methode: Prüfe, ob die ID der gewählten Option mit correctOptionId übereinstimmt
                                const selectedOption = question.options[answer];
                                isCorrect = selectedOption && selectedOption.id === question.correctOptionId;
                            } else {
                                // Fallback auf index-basierte Methode
                                isCorrect = answer === question.correct;
                            }

                            if (answer !== null && !isCorrect) {
                                const wrongAnswerDiv = document.createElement('div');
                                wrongAnswerDiv.className = 'wrong-answer-item';

                                // Ermittle die richtigen Texte für gewählte und korrekte Antwort
                                let userAnswerText;
                                let correctAnswerText;

                                // Prüfe, ob wir es mit Objekt-Optionen oder einfachen Strings zu tun haben
                                if (typeof question.options[answer] === 'object' && question.options[answer] !== null) {
                                    userAnswerText = question.options[answer].text;
                                } else {
                                    userAnswerText = question.options[answer];
                                }

                                // Bestimme den Index der richtigen Antwort - verwende bevorzugt ID-Methode wenn verfügbar
                                let correctIndex = question.correct; // Fallback

                                if (question.correctOptionId) {
                                    // Suche die Option mit der richtigen ID
                                    question.options.forEach((option, idx) => {
                                        if (option.id === question.correctOptionId) {
                                            correctIndex = idx;
                                        }
                                    });
                                }

                                if (typeof question.options[correctIndex] === 'object' && question.options[correctIndex] !== null) {
                                    correctAnswerText = question.options[correctIndex].text;
                                } else {
                                    correctAnswerText = question.options[correctIndex];
                                }

                                wrongAnswerDiv.innerHTML = `
                            <p><strong>Frage ${index + 1}:</strong> ${question.question}</p>
                            <p class="text-danger">Deine Antwort: ${userAnswerText}</p>
                            <p class="text-success">Richtige Antwort: ${correctAnswerText}</p>
                        `;
                                wrongAnswersList.appendChild(wrongAnswerDiv);
                            }
                        });

                        wrongAnswersContainer.appendChild(wrongAnswersList);
                    }
                },


                // Modal für "Zeit abgelaufen" anzeigen
                showTimeUpModal: function () {
                    // Setze den Modal-Kontext auf 'timeUp'
                    this.currentModalContext = 'timeUp';

                    this.showModal(
                        'Zeit abgelaufen',
                        'Die Zeit für diesen Test ist abgelaufen.',
                        'OK',
                        null, // Kein Abbrechen-Button nötig
                        () => {
                            // Nach dem Bestätigen des Modals die Ergebnisse anzeigen
                            this.showResults();
                        }
                    );
                },

                showModal: function (title, message, confirmText, cancelText, confirmCallback) {
                    const modal = document.getElementById('quiz-modal');
                    const modalTitle = document.getElementById('modal-title');
                    const modalBody = document.getElementById('modal-body');
                    const confirmButton = document.getElementById('modal-confirm');
                    const cancelButton = document.getElementById('modal-cancel');

                    // Das X zum Schließen des Modals verstecken
                    const closeModalButton = document.querySelector('.modal-close');
                    if (closeModalButton) {
                        closeModalButton.style.display = 'none';
                    }

                    // GEÄNDERTE FUNKTIONALITÄT: Timer soll anhalten, wenn ein Modal geöffnet ist
                    // und ab der gleichen Stelle weiterlaufen, wenn das Modal geschlossen wird
                    const timerWasRunning = this.questionTimerInterval !== null && this.isExamMode;

                    // Speichere den aktuellen Timer-Stand, um später genau dort weiterzumachen
                    if (timerWasRunning && this.remainingQuestionTime !== undefined) {
                        // Speichere die verbleibende Zeit beim Pausieren
                        this.savedQuestionTime = this.remainingQuestionTime;
                        // Log entfernt

                        // Timer anhalten
                        clearInterval(this.questionTimerInterval);
                        this.questionTimerInterval = null;
                        // Log entfernt
                    }

                    // Text im Button direkt auf Kleinbuchstaben setzen
                    const confirmSpan = confirmButton.querySelector('span');
                    const cancelSpan = cancelButton.querySelector('span');

                    modalTitle.textContent = title;

                    // Unterstützung für HTML-Inhalte in der Nachricht
                    modalBody.innerHTML = message;

                    // Bestätigen-Button konfigurieren
                    confirmButton.querySelector('span').textContent = confirmText;
                    confirmButton.querySelector('span').style.textTransform = 'none';

                    // Stile für den Bestätigen-Button setzen (grün für OK-Button)
                    if (confirmText === 'OK') {
                        confirmButton.style.backgroundColor = '#198754'; // Grün
                        confirmButton.style.color = 'white';
                        confirmButton.style.border = 'none';
                    } else {
                        // Standard-Stil wiederherstellen, falls es nicht der OK-Button ist
                        confirmButton.style.backgroundColor = '';
                        confirmButton.style.color = '';
                        confirmButton.style.border = '';
                    }

                    // Abbrechen-Button konfigurieren (kann optional sein)
                    if (cancelText) {
                        cancelButton.style.display = 'inline-block';
                        cancelButton.querySelector('span').textContent = cancelText;
                        cancelButton.querySelector('span').style.textTransform = 'none';
                    } else {
                        // Wenn kein cancelText angegeben ist, Button ausblenden
                        cancelButton.style.display = 'none';
                    }

                    // Self-reference für den Zugriff innerhalb der Eventhandler
                    const self = this;

                    // Store callback for later execution and resume timer when modal is closed
                    confirmButton.onclick = function () {
                        modal.classList.remove('show');
                        document.body.classList.remove('modal-open');

                        // Timer nur wieder starten, wenn das Modal nicht für einen Moduswechsel war
                        // In diesem Fall prüfen wir nur den currentModalContext
                        if (timerWasRunning && self.currentModalContext !== 'switchMode') {
                            self.startQuestionTimer();
                            // Log entfernt
                        }

                        // Zurücksetzen des Modal-Kontexts
                        self.currentModalContext = null;

                        if (typeof confirmCallback === 'function') {
                            confirmCallback();
                        }
                    };

                    cancelButton.onclick = function () {
                        modal.classList.remove('show');
                        document.body.classList.remove('modal-open');

                        // Timer wieder starten, wenn er vorher lief UND wir nicht im switchMode-Kontext waren
                        if (timerWasRunning && self.currentModalContext !== 'switchMode') {
                            self.startQuestionTimer();
                            // Log entfernt
                        }

                        // Zurücksetzen des Modal-Kontexts
                        self.currentModalContext = null;
                    };

                    if (closeModalButton) {
                        closeModalButton.onclick = function () {
                            modal.classList.remove('show');
                            document.body.classList.remove('modal-open');

                            // Timer wieder starten, wenn er vorher lief UND wir nicht im switchMode-Kontext waren
                            if (timerWasRunning && self.currentModalContext !== 'switchMode') {
                                self.startQuestionTimer();
                                // Log entfernt
                            }

                            // Zurücksetzen des Modal-Kontexts
                            self.currentModalContext = null;
                        };
                    }

                    // Close modal when clicking outside content and resume timer
                    window.onclick = function (event) {
                        if (event.target === modal) {
                            modal.classList.remove('show');
                            document.body.classList.remove('modal-open');

                            // Timer wieder starten, wenn er vorher lief UND wir nicht im switchMode-Kontext waren
                            if (timerWasRunning && self.currentModalContext !== 'switchMode') {
                                self.startQuestionTimer();
                                // Log entfernt
                            }

                            // Zurücksetzen des Modal-Kontexts
                            self.currentModalContext = null;
                        }
                    };

                    // Show modal
                    modal.classList.add('show');
                    document.body.classList.add('modal-open');
                },

                showSwitchModeAlert: function () {
                    // Timer anhalten, wenn der Benutzer den Modus wechseln möchte
                    // Der Timer wird nicht wieder gestartet, wenn auf "Ja" geklickt wird
                    const wasExamMode = this.isExamMode;
                    if (this.questionTimerInterval) {
                        clearInterval(this.questionTimerInterval);
                        this.questionTimerInterval = null;
                    }

                    // Get current mode for text customization
                    const currentMode = this.isExamMode;
                    const modalMessage = currentMode ?
                        'Möchten Sie wirklich den Modus wechseln? Ihr Prüfungs-Fortschritt wird zurückgesetzt.' :
                        'Möchten Sie wirklich den Modus wechseln? Ihr Test-Fortschritt wird zurückgesetzt.';

                    this.currentModalContext = 'switchMode';

                    // Markierungen zurücksetzen beim Moduswechsel (markierte und falsche Fragen)
                    this.markedQuestions.clear();
                    this.examMarkedQuestions.clear();
                    this.originalMarkedQuestions.clear();

                    this.showModal(
                        'Modus Wechseln',
                        modalMessage,
                        'Ja',
                        'Abbrechen',
                        () => {
                            // Direkt Timer komplett stoppen wenn wir im Prüfungsmodus sind,
                            // völlig unabhängig vom Modal-Kontext
                            if (wasExamMode) {
                                // SEHR WICHTIG: Endgültig verhindern, dass der Timer wieder startet
                                // Mehrere Absicherungen einbauen

                                // 1. Timer-Flag setzen
                                this.timerStopped = true;

                                // 2. Sicherstellen, dass der Timer wirklich gestoppt ist
                                if (this.questionTimerInterval) {
                                    clearInterval(this.questionTimerInterval);
                                    this.questionTimerInterval = null;
                                    // Log entfernt
                                }

                                // 3. Timer-Element verstecken
                                const timerElement = document.querySelector('.exam-timer');
                                if (timerElement) {
                                    timerElement.style.display = 'none';
                                    // Log entfernt
                                }
                            }

                            document.querySelector('.mode-selection').style.display = 'block';
                            document.querySelector('.quiz-content').style.display = 'none';
                            document.querySelector('.results-container').style.display = 'none';

                            // Entferne die 'exam-mode' Klasse vom body, wenn wir zur Modusauswahl zurückkehren
                            document.body.classList.remove('exam-mode');


                            // Wichtig: Wenn wir von der Statistikseite kommen, müssen wir
                            // sicherstellen, dass die Modus-Buttons korrekt funktionieren
                            initializeButtons();
                        }
                    );
                },
                updateFilterButtons: function () {
                    // Im Prüfungsmodus: Filter-Buttons komplett deaktivieren
                    if (this.isExamMode) {
                        const filterButtons = document.querySelector('.filter-buttons');
                        if (filterButtons) {
                            filterButtons.style.display = 'none';
                        }
                        return; // Abbrechen der Funktion im Prüfungsmodus
                    }

                    // Der "Markierte Fragen laden" Button wurde entfernt
                    const wrongButton = document.querySelector('.filter-button.wrong-questions');

                    // Spezielle Funktion zur sicheren Aktualisierung des wrongButton
                    const updateWrongButton = () => {
                        if (wrongButton) {
                            if (this.wrongQuestions.size === 0) {
                                // Log entfernt
                                wrongButton.disabled = true;
                                wrongButton.classList.add('disabled');
                                // Inline-Stile für sofortige visuelle Änderung
                                wrongButton.style.backgroundColor = "#6c757d";
                                wrongButton.style.color = "#e6e6e6";
                                wrongButton.style.cursor = "not-allowed";
                                wrongButton.style.opacity = "0.65";
                                wrongButton.style.pointerEvents = "none";
                            } else {
                                // Log entfernt
                                wrongButton.disabled = false;
                                wrongButton.classList.remove('disabled');
                                // Entferne Inline-Stile, damit das normale Aussehen zurückkommt
                                wrongButton.style.backgroundColor = "#dc3545";
                                wrongButton.style.color = "white";
                                wrongButton.style.cursor = "pointer";
                                wrongButton.style.opacity = "1";
                                wrongButton.style.pointerEvents = "auto";
                            }
                        }
                    };

                    // Der "Markierte Fragen laden" Button wurde entfernt

                    // Rufe die spezielle Funktion auf
                    updateWrongButton();

                    // Zusätzliche Verzögerung, um sicherzustellen, dass der Button-Status angewendet wird
                    setTimeout(updateWrongButton, 100);
                },
                initializeQuiz: function (mode) {
                    // Robustes Debugging-Log für Initialisierungsprozess
                    console.log("initializeQuiz wird gestartet. Modus:", mode);

                    try {
                        // Timer stoppen, falls er bereits läuft
                        if (this.questionTimerInterval) {
                            clearInterval(this.questionTimerInterval);
                            this.questionTimerInterval = null;
                        }

                        // Timer-Element zurücksetzen und auf Standardfarbe setzen
                        const timerElement = document.querySelector('.exam-timer');
                        if (timerElement) {
                            timerElement.style.backgroundColor = 'white';
                            timerElement.style.color = '#1d232b';
                        }

                        // Setze den Modus
                        this.isExamMode = mode === 'exam';
                        console.log("Modus wurde gesetzt:", this.isExamMode ? "Prüfung" : "Training");

                        // Wichtig: timerStopped zurücksetzen, wenn wir in den Prüfungsmodus wechseln
                        if (this.isExamMode) {
                            this.timerStopped = false;
                        }

                        // Füge die Klasse 'exam-mode' zum body hinzu oder entferne sie
                        if (mode === 'exam') {
                            document.body.classList.add('exam-mode');

                            // Timer für den Prüfungsmodus wird später in startQuiz gestartet
                        } else {
                            document.body.classList.remove('exam-mode');
                        }

                        // Alle Filter und Status zurücksetzen
                        this.isFilteredWrongQuestions = false; // Zurücksetzen beim Modiwechsel
                        this.isFilteredMarkedQuestions = false; // Zurücksetzen des Modus für markierte Fragen
                        this.quizCompleted = false; // Wichtig: Setze den Status zurück

                        // Je nachdem ob wir in den Prüfungsmodus oder Trainingsmodus wechseln,
                        // bereiten wir die Markierungen unterschiedlich vor

                        // Initialisiere alle Sets, falls sie noch nicht existieren
                        if (!this.wrongQuestions) this.wrongQuestions = new Set();
                        if (!this.originalWrongQuestions) this.originalWrongQuestions = new Set();
                        if (!this.markedQuestions) this.markedQuestions = new Set();
                        if (!this.examMarkedQuestions) this.examMarkedQuestions = new Set();
                        if (!this.originalMarkedQuestions) this.originalMarkedQuestions = new Set();

                        // Falsche Fragen immer zurücksetzen
                        this.wrongQuestions.clear();
                        this.originalWrongQuestions.clear();

                        // Speichere die aktuellen Markierungen temporär
                        const oldMarkedQuestions = Array.from(this.markedQuestions || []);

                        // Alle Markierungen zurücksetzen - Wichtig für einen sauberen Neustart
                        this.markedQuestions.clear();
                        this.examMarkedQuestions.clear();
                        this.originalMarkedQuestions.clear();

                        // Lösche alle gespeicherten Markierungen und falschen Fragen in Cookies
                        setCookie(COOKIE_NAMES.WRONG_QUESTIONS, []);
                        setCookie(COOKIE_NAMES.ORIGINAL_WRONG_QUESTIONS, []);

                        console.log("Quiz-Status zurückgesetzt, starte Quiz...");

                        // Start the quiz after initialization
                        this.startQuiz(this.isExamMode);
                    } catch (error) {
                        console.error("Fehler beim Initialisieren des Quiz:", error);
                        // Versuche trotzdem das Quiz zu starten, um Nutzererfahrung zu verbessern
                        try {
                            this.startQuiz(this.isExamMode);
                        } catch (e) {
                            console.error("Konnte Quiz nach Fehler nicht starten:", e);
                            alert("Es ist ein Fehler aufgetreten. Bitte aktualisieren Sie die Seite.");
                        }
                    }
                },

                // Verbesserte Version der updateQuestionIndicators-Funktion
                updateQuestionIndicators: function () {
                    console.log("Aktualisiere Fragenindikatoren...");

                    // WICHTIG: Stelle sicher, dass alle Sets initialisiert sind
                    if (!this.markedQuestions) this.markedQuestions = new Set();
                    if (!this.examMarkedQuestions) this.examMarkedQuestions = new Set();
                    if (!this.originalMarkedQuestions) this.originalMarkedQuestions = new Set();

                    // Hole alle Indikator-Elemente
                    const allIndicators = document.querySelectorAll('.question-indicator');
                    if (!allIndicators || allIndicators.length === 0) {
                        console.log("Keine Indikatoren gefunden, erzeuge sie zuerst.");
                        // Wenn keine Indikatoren vorhanden sind, erzeuge sie zuerst
                        this.updateQuestionOverview();
                        // Dann erneut versuchen, die Indikatoren zu erhalten
                        const newIndicators = document.querySelectorAll('.question-indicator');
                        if (!newIndicators || newIndicators.length === 0) {
                            console.error("Konnte keine Indikatoren erzeugen.");
                            return;
                        }
                    }

                    console.log("Aktualisiere", allIndicators.length, "Indikatoren.");

                    // Für jeden Indikator den Markierungsstatus neu berechnen und die CSS-Klassen setzen
                    allIndicators.forEach((indicator, index) => {
                        // Die Frage für diesen Index holen
                        const currentQuestion = this.questions[index];
                        if (!currentQuestion || !currentQuestion.id) {
                            console.warn("Frage", index, "hat keine ID oder existiert nicht");
                            return;
                        }

                        // ID der Frage ermitteln (viel bessere Methode als indices)
                        const questionId = currentQuestion.id;

                        // Prüfen, ob die Frage mit dieser ID markiert ist
                        const isMarked = this.isQuestionMarked(questionId);
                        console.log("Frage mit ID", questionId, "markiert?", isMarked);

                        // Klassen entsprechend setzen - wichtig für die visuelle Darstellung
                        if (isMarked) {
                            indicator.classList.add('marked');
                        } else {
                            indicator.classList.remove('marked');
                        }

                        // Zusätzlich zur Markierung müssen wir auch den Antwort-Status aktualisieren
                        if (this.userAnswers && this.userAnswers[index] !== null && this.userAnswers[index] !== undefined) {
                            // Wenn die Frage beantwortet ist, zeige den Status je nach Markierung
                            let isCorrect = false;

                            // Überprüfe die Korrektheit mit bevorzugter ID-Methode
                            if (this.questions[index].correctOptionId && this.userAnswers[index] !== null) {
                                // ID-basierte Methode: Überprüfe die ID der gewählten Antwort
                                const selectedOption = this.questions[index].options[this.userAnswers[index]];
                                isCorrect = selectedOption && selectedOption.id === this.questions[index].correctOptionId;
                            } else {
                                // Fallback auf die Index-basierte Methode
                                isCorrect = this.questions[index] &&
                                    this.userAnswers[index] === this.questions[index].correct;
                            }

                            // Entferne zuerst alle Status-Klassen
                            indicator.classList.remove(
                                'correct', 'incorrect',
                                'marked-correct', 'marked-incorrect'
                            );

                            // Setze dann die korrekten Klassen
                            if (isMarked) {
                                // Markierte Fragen behalten orange Farbe, bekommen aber Rahmen
                                if (isCorrect) {
                                    indicator.classList.add('marked-correct');
                                } else {
                                    indicator.classList.add('marked-incorrect');
                                }
                            } else {
                                // Nicht-markierte Fragen werden grün/rot
                                if (isCorrect) {
                                    indicator.classList.add('correct');
                                } else {
                                    indicator.classList.add('incorrect');
                                }
                            }
                        }

                        // Stelle sicher, dass der aktuelle Indikator hervorgehoben ist
                        if (index === this.currentQuestion) {
                            indicator.classList.add('current');
                        } else {
                            indicator.classList.remove('current');
                        }
                    });

                    // Nach der Aktualisierung der Indikatoren den Mark-Button aktualisieren
                    this.updateMarkButton();
                },
                renderQuestion: function () {
                    this.loadQuestion();
                },
                showFinishConfirmation: function () {
                    // Timer anhalten, wenn der Benutzer den Test vorzeitig beenden möchte
                    // Wird fortgesetzt, wenn der Modal geschlossen wird
                    if (this.questionTimerInterval) {
                        clearInterval(this.questionTimerInterval);
                    }

                    // Zähle unbeantwortete Fragen
                    const unansweredCount = this.userAnswers.filter(answer => answer === null).length;

                    // Modaltext je nach Modus anpassen
                    const modalTitle = this.isExamMode ? 'Prüfung beenden' : 'Test beenden';

                    // Erstelle die Meldung
                    let message = this.isExamMode ?
                        'Möchten Sie die Prüfung wirklich beenden und Ihre Ergebnisse sehen?' :
                        'Möchten Sie den Test wirklich beenden und Ihre Ergebnisse sehen?';

                    // Wenn es unbeantwortete Fragen gibt, füge die Warnung hinzu
                    if (unansweredCount > 0) {
                        message += '<div style="color: #dc3545; font-weight: bold; margin-top: 15px;">Achtung: Du hast ' +
                            unansweredCount + ' Fragen noch nicht beantwortet!</div>';
                    }

                    this.showModal(
                        modalTitle,
                        message,
                        'Ja',
                        'Nein',
                        () => {
                            this.showResults();
                        }
                    );
                }
            };

            // Initialize buttons and event listeners
            function initializeButtons() {
                // Log entfernt
                const trainingButton = document.querySelector('.mode-button.training');
                const examButton = document.querySelector('.mode-button.exam');

                if (trainingButton) {
                    // Log entfernt
                    trainingButton.addEventListener('click', function () {
                        // Log entfernt
                        window.squarespaceQuiz.initializeQuiz('training');
                    });
                } else {
                    // Fehler-Log entfernt
                }

                if (examButton) {
                    // Log entfernt
                    examButton.addEventListener('click', function () {
                        // Log entfernt
                        window.squarespaceQuiz.initializeQuiz('exam');
                    });
                } else {
                    // Fehler-Log entfernt
                }
            }

            // Hilfsfunktion zum Debuggen von Fragen
            function debugQuestions() {
                console.log("DEBUG: Fragen prüfen");
                if (!window.squarespaceQuiz || !window.squarespaceQuiz.questions) {
                    console.error("Keine Fragen gefunden - Quiz nicht initialisiert");
                    return;
                }

                console.log(`Quiz hat ${window.squarespaceQuiz.questions.length} Fragen`);

                // Prüfen, ob alle Fragen IDs haben
                const questionsWithoutIds = window.squarespaceQuiz.questions.filter(q => !q.id);
                if (questionsWithoutIds.length > 0) {
                    console.warn(`${questionsWithoutIds.length} Fragen haben keine ID!`);
                }

                // Prüfen, ob IDs eindeutig sind
                const ids = window.squarespaceQuiz.questions.map(q => q.id);
                const uniqueIds = new Set(ids);
                if (uniqueIds.size < ids.length) {
                    console.warn("Achtung: Doppelte Frage-IDs gefunden!");
                }
            }

            // Initialize everything when DOM is loaded
            window.addEventListener('DOMContentLoaded', function () {
                console.log("DOM vollständig geladen, initialisiere Quiz...");

                // Initialisiere die Buttons
                initializeButtons();

                // Stelle sicher, dass die Fragen korrekt geladen werden
                if (window.squarespaceQuiz) {
                    window.squarespaceQuiz.initializeQuestions();

                    // Führe eine Diagnose der Fragen durch
                    setTimeout(debugQuestions, 500);
                }
            });

            // Bei der Initialisierung immer den "Falsche Fragen laden" Button deaktivieren
            // beim ersten Laden gibt es noch keine falschen Fragen
            // Zuerst alle gespeicherten falschen Fragen zurücksetzen
            setCookie(COOKIE_NAMES.WRONG_QUESTIONS, []);
            setCookie(COOKIE_NAMES.ORIGINAL_WRONG_QUESTIONS, []);

            // Dann den Button visuell deaktivieren
            const wrongButton = document.querySelector('.filter-button.wrong-questions');
            if (wrongButton) {
                // Log entfernt
                wrongButton.disabled = true;
                wrongButton.classList.add('disabled');
                // Inline-Stile für sofortige visuelle Änderung
                wrongButton.style.backgroundColor = "#6c757d";
                wrongButton.style.color = "#e6e6e6";
                wrongButton.style.cursor = "not-allowed";
                wrongButton.style.opacity = "0.65";
                wrongButton.style.pointerEvents = "none";
            }

            // Rest of your event listeners and code
            document.querySelector('.back-button').addEventListener('click', () => {
                if (window.squarespaceQuiz.currentQuestion > 0) {
                    window.squarespaceQuiz.currentQuestion--;
                    window.squarespaceQuiz.loadQuestion();
                    window.squarespaceQuiz.updateQuestionOverview();

                    // Wenn wir im falschen Fragen Modus sind, korrigiere die Hervorhebung
                    if (window.squarespaceQuiz.isFilteredWrongQuestions) {
                        window.squarespaceQuiz.fixNavigationHighlighting();
                    }
                }
            });

            document.querySelector('.next-button').addEventListener('click', () => {
                if (window.squarespaceQuiz.currentQuestion < window.squarespaceQuiz.questions.length - 1) {
                    window.squarespaceQuiz.currentQuestion++;
                    window.squarespaceQuiz.loadQuestion();
                    window.squarespaceQuiz.updateQuestionOverview();

                    // Wenn wir im falschen Fragen Modus sind, korrigiere die Hervorhebung
                    if (window.squarespaceQuiz.isFilteredWrongQuestions) {
                        window.squarespaceQuiz.fixNavigationHighlighting();

                        // Wenn wir das Ende eines Blocks erreicht haben, aktualisiere die Übersicht
                        const blockSize = window.innerWidth <= 768 ? 5 : 10;
                        if ((window.squarespaceQuiz.currentQuestion + 1) % blockSize === 0) {
                            window.squarespaceQuiz.updateQuestionOverview();
                            window.squarespaceQuiz.fixNavigationHighlighting();
                        }
                    }
                }
            });

            // Toggle-Button für Markierungen - einfach gehalten für bessere Kompatibilität
            const markButton = document.querySelector('.mark-button');
            if (markButton) {
                // Wichtig: Init markButton aktiver Status basierend auf aktuellem Quiz-Status
                window.squarespaceQuiz.updateMarkButton();

                // Event-Listener für den Klick, der die Markierung umschaltet
                markButton.addEventListener('click', (e) => {
                    // Verhindern Standard-Verhalten
                    e.preventDefault();

                    console.log("Mark-Button wurde geklickt");

                    // Die aktuelle Frage und ihre ID ermitteln
                    const currentQuestionIndex = window.squarespaceQuiz.currentQuestion;
                    const currentQuestion = window.squarespaceQuiz.questions[currentQuestionIndex];

                    if (!currentQuestion || !currentQuestion.id) {
                        console.error("Aktuelle Frage hat keine gültige ID");
                        return;
                    }

                    const questionId = currentQuestion.id;
                    console.log("Markieren/Demarkieren der Frage mit ID:", questionId);

                    // Ist die Frage aktuell markiert?
                    const isMarkedBefore = window.squarespaceQuiz.isQuestionMarked(questionId);
                    console.log("Frage war vorher markiert:", isMarkedBefore);

                    // Toggle-Funktion aufrufen mit dem aktuellen Fragen-Index
                    // Die Funktion wird die ID selbst ermitteln
                    window.squarespaceQuiz.toggleMarkQuestion(currentQuestionIndex);

                    // Ist die Frage jetzt markiert?
                    const isMarkedAfter = window.squarespaceQuiz.isQuestionMarked(questionId);
                    console.log("Frage ist jetzt markiert:", isMarkedAfter);

                    // SOFORTIGE UI-AKTUALISIERUNG: Button-Status aktualisieren
                    markButton.classList.toggle('active', isMarkedAfter);
                    markButton.classList.toggle('marked', isMarkedAfter);
                    markButton.title = isMarkedAfter ? 'Markierung entfernen' : 'Frage markieren';
                    markButton.innerHTML = '<i class="fas fa-bookmark"></i>';
                    markButton.style.color = isMarkedAfter ? '#1d232b' : '#ffffff';

                    // SOFORTIGE UI-AKTUALISIERUNG: Indikator-Status aktualisieren
                    // Wir verwenden die data-question-id, um den korrekten Indikator zu finden
                    const allIndicators = document.querySelectorAll('.question-indicator');
                    let currentIndicator = null;

                    // Suche nach dem Indikator mit der passenden ID
                    allIndicators.forEach(indicator => {
                        const originalIndex = indicator.dataset.originalIndex;
                        if (originalIndex !== undefined && parseInt(originalIndex) === currentQuestionIndex) {
                            currentIndicator = indicator;
                        }
                    });

                    if (currentIndicator) {
                        if (isMarkedAfter) {
                            currentIndicator.classList.add('marked');
                        } else {
                            currentIndicator.classList.remove('marked');
                        }
                        console.log("Indikator-Klassen aktualisiert:", currentIndicator.className);
                    }

                    // Alle UI-Komponenten vollständig aktualisieren
                    window.squarespaceQuiz.updateMarkButton();
                    window.squarespaceQuiz.updateQuestionIndicators();
                    window.squarespaceQuiz.updateQuestionOverview();

                    // Diese redundante Update-Funktion wurde entfernt, 
                    // da updateQuestionIndicators und updateQuestionOverview bereits aufgerufen werden
                    // und alle erforderlichen UI-Aktualisierungen durchführen.
                });
            }

            document.querySelector('.submit-button').addEventListener('click', () => {
                window.squarespaceQuiz.showFinishConfirmation();
            });

            document.querySelector('.retry-button').addEventListener('click', () => {
                // Timer anhalten, wenn der Benutzer den Test neu starten möchte
                // Der Timer wird wieder gestartet, wenn das Modal geschlossen wird
                if (window.squarespaceQuiz.questionTimerInterval) {
                    clearInterval(window.squarespaceQuiz.questionTimerInterval);
                }

                // Get current mode for text customization
                const currentMode = window.squarespaceQuiz.isExamMode;
                const modalTitle = currentMode ? 'Prüfung neu starten' : 'Test neu starten';
                const modalMessage = currentMode ?
                    'Möchten Sie die Prüfung wirklich neu starten? Ihre Antworten werden zurückgesetzt.' :
                    'Möchten Sie den Test wirklich neu starten? Ihre Antworten werden zurückgesetzt.';

                // Use modal for confirmation
                window.squarespaceQuiz.showModal(
                    modalTitle,
                    modalMessage,
                    'Ja',
                    'Abbrechen',
                    () => {
                        // Get current mode and restart quiz
                        const currentMode = window.squarespaceQuiz.isExamMode;

                        // Reset all marked questions before restarting the quiz
                        window.squarespaceQuiz.markedQuestions = new Set();
                        window.squarespaceQuiz.originalMarkedQuestions = new Set();
                        window.squarespaceQuiz.examMarkedQuestions = new Set();

                        // Cookie-Funktionalität für markierte Fragen wurde deaktiviert
                        // setCookie-Aufrufe für markierte Fragen entfernt

                        // Timer-Element zurücksetzen und auf Standardfarbe setzen
                        const timerElement = document.querySelector('.exam-timer');
                        if (timerElement) {
                            timerElement.style.backgroundColor = 'white';
                            timerElement.style.color = '#1d232b';
                        }

                        // Quiz neu starten, was auch den Timer neu startet
                        window.squarespaceQuiz.initializeQuiz(currentMode ? 'exam' : 'training');
                    }
                );
            });

            document.querySelector('.switch-mode-button').addEventListener('click', () => {
                window.squarespaceQuiz.showSwitchModeAlert();
            });

            // Update reset button event listener
            document.querySelector('.reset-button').addEventListener('click', () => {
                // Timer anhalten, wenn der Benutzer zur Modusauswahl zurückkehren möchte
                // Der Timer wird wieder gestartet, wenn das Modal geschlossen wird
                if (window.squarespaceQuiz.questionTimerInterval) {
                    clearInterval(window.squarespaceQuiz.questionTimerInterval);
                }

                // Get current mode for text customization
                const currentMode = window.squarespaceQuiz.isExamMode;
                const modalMessage = currentMode ?
                    'Möchten Sie wirklich die Prüfung zurücksetzen und zur Modusauswahl zurückkehren?' :
                    'Möchten Sie wirklich den Test zurücksetzen und zur Modusauswahl zurückkehren?';

                window.squarespaceQuiz.showModal(
                    'Zurück zur Modusauswahl',
                    modalMessage,
                    'Ja',
                    'Abbrechen',
                    () => {
                        // Zur Modusauswahl zurückkehren
                        document.querySelector('.mode-selection').style.display = 'block';
                        document.querySelector('.quiz-content').style.display = 'none';
                        document.querySelector('.results-container').style.display = 'none';

                        // Entferne die 'exam-mode' Klasse vom body, wenn wir zur Modusauswahl zurückkehren
                        document.body.classList.remove('exam-mode');



                        // Alle Antworten zurücksetzen
                        window.squarespaceQuiz.userAnswers = new Array(window.squarespaceQuiz.questions.length).fill(null);
                        window.squarespaceQuiz.wrongQuestions = new Set();

                        // Zurück zur ersten Frage
                        window.squarespaceQuiz.currentQuestion = 0;

                        // Wichtig: Buttons initialisieren, um sicherzustellen, dass die Modusauswahl funktioniert
                        initializeButtons();
                    }
                );
            });

            // Navigation in der Fragenübersicht
            document.getElementById('overview-prev').addEventListener('click', () => {
                // Bestimme die Blockgröße
                const isMobile = window.innerWidth <= 768;
                const blockSize = isMobile ? 5 : 10;

                // Berechne den aktuellen Block
                const currentBlock = Math.floor(window.squarespaceQuiz.currentQuestion / blockSize);

                // Überprüfe, ob wir uns im Modus für falsche Fragen befinden
                const isFilteredWrongQuestions = window.squarespaceQuiz.isFilteredWrongQuestions || false;

                // Gehe zum vorherigen Block, wenn möglich
                if (isFilteredWrongQuestions) {
                    // Spezielle Handhabung für falsche Fragen
                    if (window.squarespaceQuiz.currentQuestion >= blockSize) {
                        // Es gibt einen vorherigen Block
                        const newPosition = window.squarespaceQuiz.currentQuestion - blockSize;
                        window.squarespaceQuiz.currentQuestion = newPosition;
                        window.squarespaceQuiz.loadQuestion();
                        window.squarespaceQuiz.updateQuestionOverview();
                        window.squarespaceQuiz.fixNavigationHighlighting();
                    } else if (window.squarespaceQuiz.currentQuestion > 0) {
                        // Es gibt keine vorherigen Blöcke, aber wir können eine Frage zurückgehen
                        window.squarespaceQuiz.currentQuestion--;
                        window.squarespaceQuiz.loadQuestion();
                        window.squarespaceQuiz.updateQuestionOverview();
                        window.squarespaceQuiz.fixNavigationHighlighting();
                    }
                } else {
                    // Normaler Modus
                    if (currentBlock > 0) {
                        // Wechsle zum vorherigen Block
                        const newBlock = currentBlock - 1;
                        // Setze die neue aktuelle Frage auf den Anfang des Blocks
                        window.squarespaceQuiz.currentQuestion = newBlock * blockSize;
                        window.squarespaceQuiz.loadQuestion();
                        window.squarespaceQuiz.updateQuestionOverview();
                    } else if (window.squarespaceQuiz.currentQuestion > 0) {
                        // Falls wir nicht zum vorherigen Block wechseln können, gehe einfach zur vorherigen Frage
                        window.squarespaceQuiz.currentQuestion--;
                        window.squarespaceQuiz.loadQuestion();
                        window.squarespaceQuiz.updateQuestionOverview();
                    }
                }
            });

            document.getElementById('overview-next').addEventListener('click', () => {
                // Bestimme die Blockgröße
                const isMobile = window.innerWidth <= 768;
                const blockSize = isMobile ? 5 : 10;

                // Überprüfe, ob wir uns im Modus für falsche Fragen befinden
                const isFilteredWrongQuestions = window.squarespaceQuiz.isFilteredWrongQuestions || false;
                const totalQuestions = window.squarespaceQuiz.questions.length;

                if (isFilteredWrongQuestions) {
                    // Spezielle Handhabung für falsche Fragen
                    // Berechne, ob es einen nächsten Block gibt
                    const nextBlockStart = Math.ceil((window.squarespaceQuiz.currentQuestion + 1) / blockSize) * blockSize;

                    if (nextBlockStart < totalQuestions) {
                        // Es gibt einen nächsten Block
                        window.squarespaceQuiz.currentQuestion = nextBlockStart;
                        window.squarespaceQuiz.loadQuestion();
                        window.squarespaceQuiz.updateQuestionOverview();
                        window.squarespaceQuiz.fixNavigationHighlighting();
                    } else if (window.squarespaceQuiz.currentQuestion < totalQuestions - 1) {
                        // Es gibt keinen nächsten Block, aber wir können zur nächsten Frage gehen
                        window.squarespaceQuiz.currentQuestion++;
                        window.squarespaceQuiz.loadQuestion();
                        window.squarespaceQuiz.updateQuestionOverview();
                        window.squarespaceQuiz.fixNavigationHighlighting();
                    }
                } else {
                    // Normaler Modus
                    // Berechne den aktuellen Block und die Gesamtzahl der Blöcke
                    const currentBlock = Math.floor(window.squarespaceQuiz.currentQuestion / blockSize);
                    const totalBlocks = Math.ceil(totalQuestions / blockSize);

                    // Gehe zum nächsten Block, wenn möglich
                    if (currentBlock < totalBlocks - 1) {
                        // Wechsle zum nächsten Block
                        const newBlock = currentBlock + 1;
                        // Setze die neue aktuelle Frage auf den Anfang des nächsten Blocks
                        window.squarespaceQuiz.currentQuestion = newBlock * blockSize;
                        window.squarespaceQuiz.loadQuestion();
                        window.squarespaceQuiz.updateQuestionOverview();
                    } else if (window.squarespaceQuiz.currentQuestion < totalQuestions - 1) {
                        // Falls wir nicht zum nächsten Block wechseln können, gehe einfach zur nächsten Frage
                        window.squarespaceQuiz.currentQuestion++;
                        window.squarespaceQuiz.loadQuestion();
                        window.squarespaceQuiz.updateQuestionOverview();
                    }
                }
            });

            // Event listeners für die Filter-Buttons
            // Der "Markierte Fragen laden" Button wurde entfernt

            // Aktualisierte Filter-Button-Handler
            document.querySelector('.filter-button.wrong-questions').addEventListener('click', function () {
                // Log entfernt

                // Lade die falschen Fragen aus dem persistenten Speicher
                const wrongFromCookie = getCookie(COOKIE_NAMES.WRONG_QUESTIONS);
                const originalWrongFromCookie = getCookie(COOKIE_NAMES.ORIGINAL_WRONG_QUESTIONS);

                // Protokolliere die vorhandenen Daten zur besseren Diagnose
                // Mehrzeiliger Log entfernt;

                // Wichtig: Aktiviere den Button immer, wenn falsche Fragen verfügbar sind
                // (Wie beim "Markierte Fragen"-Button)
                this.disabled = false;

                // Prüfen, ob falsche Fragen verfügbar sind, bevor wir das Modal anzeigen
                let hasFalseQuestions = false;

                // 1. Prüfe aktive Sitzung
                const isActiveSession = window.squarespaceQuiz.questions &&
                    window.squarespaceQuiz.questions.length > 0 &&
                    window.squarespaceQuiz.currentQuestion !== undefined;

                if (isActiveSession && window.squarespaceQuiz.wrongQuestions &&
                    window.squarespaceQuiz.wrongQuestions.size > 0) {
                    hasFalseQuestions = true;
                }
                // 2. Prüfe gespeicherte Fragen 
                else if (wrongFromCookie && wrongFromCookie.length > 0) {
                    hasFalseQuestions = true;
                }

                // Wenn keine falschen Fragen verfügbar sind, Button deaktivieren und zurückkehren
                if (!hasFalseQuestions) {
                    // Log entfernt
                    this.disabled = true;
                    this.classList.add('disabled');
                    // Inline-Stile für sofortige visuelle Änderung
                    this.style.backgroundColor = "#6c757d";
                    this.style.color = "#e6e6e6";
                    this.style.cursor = "not-allowed";
                    this.style.opacity = "0.65";
                    this.style.pointerEvents = "none";
                    return;
                }

                // Bestätigungs-Modal anzeigen, wenn falsche Fragen verfügbar sind
                window.squarespaceQuiz.showModal(
                    'Falsche Fragen laden',
                    'Möchten Sie falsch beantwortete Fragen laden?',
                    'Ja',
                    'Nein',
                    () => {
                        // Hier geht es mit dem Laden der falschen Fragen weiter,
                        // wenn der Benutzer auf 'Ja' klickt
                        // Log entfernt

                        // Bestimme die zu verwendenden falschen Fragen mit klarer Priorität
                        let wrongQuestions;

                        // KRITISCH: Wir laden jetzt NUR falsche Fragen aus dem letzten Test
                        // Die Logik wurde analog zur Funktion der markierten Fragen überarbeitet
                        // Wir wollen AUSSCHLIESSLICH die falschen Fragen des letzten abgeschlossenen Tests laden

                        // Prüfe, ob wir uns in einer aktiven Testsitzung befinden
                        const isActiveSession = window.squarespaceQuiz.questions &&
                            window.squarespaceQuiz.questions.length > 0 &&
                            window.squarespaceQuiz.currentQuestion !== undefined;
                        // Log entfernt

                        // 1. HÖCHSTE PRIORITÄT: Falsche Fragen aus einer aktiven Sitzung (aktueller Test)
                        if (isActiveSession && window.squarespaceQuiz.wrongQuestions && window.squarespaceQuiz.wrongQuestions.size > 0) {
                            // Verwende nur die falschen Fragen aus der aktuellen, aktiven Sitzung
                            wrongQuestions = Array.from(window.squarespaceQuiz.wrongQuestions);
                            // Log entfernt
                        }
                        // 2. ZWEITE PRIORITÄT: Falsche Fragen aus dem zuletzt gespeicherten Test (aber nur, wenn keine aktive Sitzung läuft)
                        else if (wrongFromCookie && wrongFromCookie.length > 0) {
                            wrongQuestions = wrongFromCookie;
                            // Log entfernt

                            // WICHTIG: Stelle sicher, dass wir KEINE älteren Werte verwenden
                            window.squarespaceQuiz.wrongQuestions = new Set(wrongQuestions);

                            // Zum Testen:
                            // Mehrzeiliger Log entfernt;
                        }
                        // 3. Keine falschen Fragen gefunden
                        else {
                            wrongQuestions = [];
                            // Log entfernt

                            // Keine Fragen gefunden - deaktiviere Button und return
                            // Log entfernt
                            this.disabled = true;
                            this.classList.add('disabled');
                            // Inline-Stile für sofortige visuelle Änderung
                            this.style.backgroundColor = "#6c757d";
                            this.style.color = "#e6e6e6";
                            this.style.cursor = "not-allowed";
                            this.style.opacity = "0.65";
                            this.style.pointerEvents = "none";
                            return;
                        }

                        // Fragen filtern und laden
                        if (wrongQuestions && wrongQuestions.length > 0) {
                            // Speichere die ursprünglichen Fragen
                            const originalQuestions = [...window.squarespaceQuiz.allQuestions];

                            // Filtere nur die falschen Fragen
                            const filteredQuestions = [];
                            const mappedIndices = []; // Array für Original-Indizes

                            // Filtere die falschen Fragen, unterstützt jetzt sowohl IDs als auch Indizes
                            wrongQuestions.forEach(idOrIndex => {
                                // Versuche zuerst, die Frage anhand ihrer ID zu finden (neue Version)
                                let foundQuestion = originalQuestions.find(q => q.id === idOrIndex);
                                let questionIndex = -1;

                                if (foundQuestion) {
                                    // Frage anhand der ID gefunden
                                    questionIndex = originalQuestions.findIndex(q => q.id === idOrIndex);
                                } else if (typeof idOrIndex === 'number' || !isNaN(Number(idOrIndex))) {
                                    // Fallback: Versuche als Index zu behandeln (alte Version)
                                    const index = Number(idOrIndex);
                                    if (index >= 0 && index < originalQuestions.length) {
                                        foundQuestion = originalQuestions[index];
                                        questionIndex = index;
                                    }
                                }

                                // Wenn wir die Frage gefunden haben, füge sie zur gefilterten Liste hinzu
                                if (foundQuestion && questionIndex >= 0) {
                                    filteredQuestions.push(foundQuestion);
                                    mappedIndices.push(questionIndex); // Speichere den Original-Index
                                }
                            });

                            // Log entfernt

                            // Update UI
                            document.querySelector('.results-container').style.display = 'none';
                            document.querySelector('.question-container').style.display = 'block';
                            document.querySelector('.quiz-content').style.display = 'block';

                            // Wichtig: Zeige die Navigationsleiste (question-overview) an
                            document.querySelector('.question-overview').style.display = 'block';

                            // Setze die gefilterten Fragen
                            window.squarespaceQuiz.questions = filteredQuestions;
                            window.squarespaceQuiz.questionIndices = mappedIndices; // Speichere die Original-Indizes
                            window.squarespaceQuiz.currentQuestion = 0;

                            // Beim Laden der falschen Fragen setzen wir die Antworten zurück.
                            // Die Antworten sollen erst nach dem Beantworten gespeichert werden.
                            // Leeres Array mit Nullwerten, um neue Antworten zu speichern
                            window.squarespaceQuiz.userAnswers = new Array(filteredQuestions.length).fill(null);

                            // Wichtig: Alle Antwort-Buttons zurücksetzen für die aktuelle Frage
                            const optionButtons = document.querySelectorAll('.option-button');
                            optionButtons.forEach(button => {
                                button.classList.remove('correct', 'incorrect', 'selected-exam');
                                button.disabled = false;
                            });

                            // Fortschrittsleiste zurücksetzen
                            const progressBar = document.querySelector('.progress-bar');
                            progressBar.style.setProperty('--correct-percentage', '0%');
                            progressBar.style.setProperty('--answered-percentage', '0%');

                            // WICHTIG: Bei falschen Fragen die Markierungen zurücksetzen!
                            window.squarespaceQuiz.markedQuestions = new Set();
                            window.squarespaceQuiz.examMarkedQuestions = new Set();
                            window.squarespaceQuiz.originalMarkedQuestions = new Set();

                            // Cookie-Funktionalität für markierte Fragen wurde deaktiviert
                            // setCookie-Aufrufe für markierte Fragen entfernt

                            // Behalte die aktuellen Markierungen bei, falls bereits welche gesetzt sind
                            // Mehrzeiliger Log entfernt;

                            // In diesem Kontext speichern wir keine originalWrongQuestions, 
                            // da wir bereits aus ihnen laden und sie nicht überschreiben wollen

                            // NICHT den wrongQuestions-Set zurücksetzen!
                            // Stattdessen weiterverwenden, damit die falsch beantworteten Fragen dort erfasst werden
                            // window.squarespaceQuiz.wrongQuestions = new Set();

                            // WICHTIG: Wir müssen sicherstellen, dass die Anzahl der angezeigten Fragen korrekt ist
                            // Bestimme die Blockgröße basierend auf der Bildschirmbreite
                            const isMobile = window.innerWidth <= 768;
                            const maxBlockSize = isMobile ? 5 : 10;

                            // Setze Quiz-Status für die neue Runde mit falschen Fragen
                            window.squarespaceQuiz.isFilteredWrongQuestions = true; // Setze auf true, da wir falsche Fragen filtern
                            window.squarespaceQuiz.quizCompleted = false;
                            // Markierter Fragen Modus ausschalten
                            window.squarespaceQuiz.isFilteredMarkedQuestions = false;

                            // Navigationsleiste manuell neu erstellen
                            const container = document.getElementById('overview-container');
                            if (container) {
                                container.innerHTML = '';

                                // Verwende die bereits definierte Blockgröße von oben
                                // Stell sicher, dass wir die korrekte Blockgröße verwenden: 5 für Mobil, 10 für Desktop
                                const blockSize = maxBlockSize;

                                // Beschränke die Anzahl der Fragen auf eine passende Blockgröße
                                // Das stellt sicher, dass genau die richtige Anzahl von Fragen angezeigt wird
                                // und nicht mehr als die vorgegebene Blockgröße
                                const displayCount = Math.min(blockSize, window.squarespaceQuiz.questions.length);

                                for (let i = 0; i < displayCount; i++) {
                                    const indicator = document.createElement('div');
                                    indicator.className = 'question-indicator';
                                    indicator.textContent = (i + 1).toString();

                                    // Nur die aktuelle Frage markieren
                                    if (i === 0) { // Immer mit Frage 1 starten
                                        indicator.classList.add('current');
                                    }
                                    // Prüfen ob die Frage in originalMarkedQuestions markiert ist
                                    // Hier den Original-Index aus dem mappedIndices-Array verwenden
                                    const originalIndex = mappedIndices[i];

                                    // Prüfen, ob diese Frage als markiert gespeichert ist
                                    if (window.squarespaceQuiz.originalMarkedQuestions &&
                                        window.squarespaceQuiz.originalMarkedQuestions.has(originalIndex)) {
                                        // Diese Frage war markiert, also orange darstellen
                                        indicator.classList.add("marked");
                                    }

                                    indicator.addEventListener('click', (function (index) {
                                        return function () {
                                            window.squarespaceQuiz.currentQuestion = index;

                                            // WICHTIG: Wenn wir im Modus für falsche Fragen sind und auf eine Nummer klicken,
                                            // müssen wir NUR die Frage ändern, aber im Modus für falsche Fragen bleiben
                                            if (window.squarespaceQuiz.isFilteredWrongQuestions) {
                                                // Wir bleiben im Modus für falsche Fragen
                                                // Nur den Index innerhalb der gefilterten Liste aktualisieren
                                                window.squarespaceQuiz.currentQuestion = index;
                                            }

                                            window.squarespaceQuiz.loadQuestion();
                                            window.squarespaceQuiz.updateQuestionOverview();

                                            // Wichtig: Korrigiere die Hervorhebung in der Navigation, damit nur
                                            // die aktuell ausgewählte Frage hervorgehoben wird
                                            // Dies ist besonders wichtig für falsche Fragen aus verschiedenen Blöcken
                                            window.squarespaceQuiz.fixNavigationHighlighting();
                                        };
                                    })(i));

                                    // Doppelklick Event für Markierung hinzufügen - wichtig für falsche Fragen
                                    indicator.addEventListener('dblclick', (function (index, origIndex) {
                                        return function (event) {
                                            event.preventDefault();
                                            // Den Original-Index für die Markierung verwenden
                                            window.squarespaceQuiz.toggleMarkQuestion(origIndex);

                                            // Die Frage-ID der aktuellen Frage ermitteln
                                            const questionId = window.squarespaceQuiz.questions[origIndex].id;

                                            // Indikator-Status aktualisieren - jetzt mit der eindeutigen ID
                                            if (window.squarespaceQuiz.isQuestionMarked(questionId)) {
                                                indicator.classList.add("marked");
                                            } else {
                                                indicator.classList.remove("marked");
                                            }
                                        };
                                    })(i, originalIndex));

                                    container.appendChild(indicator);
                                }
                            }

                            // Jetzt Frage laden
                            window.squarespaceQuiz.loadQuestion();

                            // Wichtig: Navigationshervorhebung korrigieren, nachdem falsche Fragen geladen wurden
                            window.squarespaceQuiz.fixNavigationHighlighting();
                        } else {
                            this.disabled = true;
                        }
                    }); // Ende der Callback-Funktion für den "Ja"-Button
            });
        });

        // Radikaler Ansatz zur Lösung des Squarespace-Höhenproblems
        document.addEventListener('DOMContentLoaded', function () {
            // Funktion, die ausgeführt wird, wenn das Quiz vollständig geladen ist
            function initQuizFixedLayout() {
                // Log entfernt

                // Den Quiz-Container finden
                const quizContainer = document.getElementById('squarespace-quiz-container');

                if (!quizContainer) {
                    // Log entfernt
                    return;
                }

                // Das direkte HTML-Element abrufen, das den übermäßigen Raum verursacht
                function fixSquarespaceLayouts() {
                    // Log entfernt

                    // 1. Korrigiere die Hauptseiten-Container von Squarespace
                    const mainContainers = [
                        'body',
                        '.sqs-layout',
                        '.page-section',
                        '.sqs-block',
                        '.sqs-block-content',
                        '.Content-outer',
                        '.Main',
                        '.Main-content'
                    ];

                    // GANZ WICHTIG: Die Höhe des HTML und BODY-Elements korrigieren
                    document.documentElement.style.height = 'auto';
                    document.body.style.height = 'auto';
                    document.body.style.minHeight = 'auto';

                    // Erzwinge eine maximale Höhe für die Seite basierend auf dem sichtbaren Inhalt
                    const visibleHeight = window.innerHeight;
                    const footerElement = document.querySelector('footer');
                    const footerHeight = footerElement ? footerElement.offsetHeight : 0;

                    // Setze eine maximale Höhe für bestimmte Layout-Container
                    mainContainers.forEach(selector => {
                        const elements = document.querySelectorAll(selector);
                        elements.forEach(el => {
                            // Nur wenn das Element den Quiz-Container enthält oder danach kommt
                            if (el.contains(quizContainer) ||
                                (quizContainer.compareDocumentPosition(el) & Node.DOCUMENT_POSITION_FOLLOWING)) {
                                // Log entfernt
                                el.style.height = 'auto';
                                el.style.minHeight = 'auto';
                                el.style.maxHeight = 'none';
                                el.style.overflow = 'visible';
                                el.style.paddingBottom = '0';
                                el.style.marginBottom = '0';
                            }
                        });
                    });

                    // 2. Verstecke alle leeren Blöcke nach dem Quiz
                    const emptyBlocks = document.querySelectorAll('.sqs-block-spacer, .sqs-block-html:empty');
                    emptyBlocks.forEach(block => {
                        const position = quizContainer.compareDocumentPosition(block);
                        if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
                            // Log entfernt
                            block.style.display = 'none';
                        }
                    });

                    // 3. Besonders aggressiver Fix für spezifische Probleme
                    // Dieser Teil fügt HTML-Attribute hinzu, um Layout-Engines zu zwingen
                    quizContainer.setAttribute('data-fixed-layout', 'true');

                    // 4. Dynamisch berechnete Höhe setzen
                    const quizHeight = quizContainer.offsetHeight;

                    // 5. Setze ein Element nach dem Quiz ein, das als "Stopper" fungiert
                    if (!document.getElementById('quiz-layout-fix')) {
                        const stopper = document.createElement('div');
                        stopper.id = 'quiz-layout-fix';
                        stopper.style.height = '1px';
                        stopper.style.width = '100%';
                        stopper.style.clear = 'both';
                        stopper.style.display = 'block';
                        stopper.style.marginTop = '-1px';
                        quizContainer.after(stopper);
                    }

                    // Log entfernt
                }

                // Führe den Fix mehrfach aus, um sicherzustellen, dass er wirkt
                fixSquarespaceLayouts();
                setTimeout(fixSquarespaceLayouts, 500);
                setTimeout(fixSquarespaceLayouts, 1000);

                // Füge CSS-Regeln hinzu, die extrem spezifisch sind
                const styleFixRules = `
            /* Extrem spezifische CSS-Regeln zur Behebung des Höhenproblems */
            html, body {
                height: auto !important;
                min-height: auto !important;
                overflow-y: auto !important;
            }
            
            /* Alle potenziell problematischen Container korrigieren */
            .sqs-layout, .page-section, .sqs-block, .Content-outer, .Main, .Main-content {
                min-height: 0 !important;
                height: auto !important;
                overflow: visible !important;
            }
            
            /* Quiz-Container fixieren */
            
            /* Footer-Bereich korrigieren */
            footer, .Footer {
                position: relative !important;
                bottom: 0 !important;
                margin-top: 0 !important;
            }
            
            /* Hack für Squarespace-spezifische Probleme */
            [data-fixed-layout="true"] {
                min-height: 0 !important;
                overflow: hidden !important;
            }
            
            /* Body-Overflow-Fix */
            body:after {
                content: "";
                display: block;
                clear: both;
                height: 0;
            }
        `;

                // Style-Element erstellen und einfügen
                const styleElement = document.createElement('style');
                styleElement.type = 'text/css';
                styleElement.innerHTML = styleFixRules;
                document.head.appendChild(styleElement);

                // Höhenkorrektur bei jedem Klick im Quiz anwenden
                document.addEventListener('click', function (e) {
                    if (quizContainer.contains(e.target)) {
                        setTimeout(fixSquarespaceLayouts, 300);
                    }
                });

                // Fenstergrößenänderung überwachen
                window.addEventListener('resize', function () {
                    setTimeout(fixSquarespaceLayouts, 300);
                });

                // MutationObserver für Änderungen im Quiz
                const observer = new MutationObserver(function () {
                    setTimeout(fixSquarespaceLayouts, 200);
                });

                observer.observe(quizContainer, {
                    childList: true,
                    subtree: true,
                    attributes: true
                });

                // Einfache Korrektur des Leerraums-Problems
                window.addEventListener('load', function () {
                    // Kurze Verzögerung für Squarespace-Layouts
                    setTimeout(function () {
                        try {
                            // Code-Block Container finden
                            let codeBlock = null;
                            let currentEl = quizContainer;
                            while (currentEl && currentEl !== document.body) {
                                if (currentEl.classList.contains('sqs-block-code') ||
                                    currentEl.classList.contains('code-block')) {
                                    codeBlock = currentEl;
                                    break;
                                }
                                currentEl = currentEl.parentElement;
                            }

                            // Fix anwenden
                            if (codeBlock) {
                                // 1. Höhe auf Quiz-Container beschränken
                                const quizHeight = quizContainer.getBoundingClientRect().height;
                                codeBlock.style.height = quizHeight + 'px';
                                codeBlock.style.overflow = 'hidden';
                            }
                        } catch (error) {
                            // Fehler ignorieren
                        }
                    }, 800);
                });
            }

            // Starten mit Verzögerung, um sicherzustellen, dass die Seite geladen ist
            setTimeout(initQuizFixedLayout, 300);
        });
    </script>



</body>

</html>
